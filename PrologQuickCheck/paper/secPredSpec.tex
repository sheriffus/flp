% -*- mode: latex; mode: folding -*-

\section{Predicate Specification}
\label{sec:pred-spec}

Here we describe our predicate specification language.
%
Throughout, we follow some of the principles presented
in~\cite{Deville1990logprog}.
%
There are several ways to state a predicate's specification, we do not
argue that our specification process is superior to other approaches.
%
We do believe that this approach fits naturally our needs, namely as a
form to express the predicate features we thought to be of importance.


The general specification form of a predicate \yap{p/n} consists, at its
core, of a set of uniquely identified specification clauses about input
types or the shape of the parameters when evoking the predicate.
%
\begin{code}
predicate specification clause
  p Id
parameter input types
  T1, ..., Tn
\end{code}
%
Various aspects of the predicate for the particular input type in
question can be added to a specification clause.
%
If there is a relation that arguments must fulfil one can implement it
as a predicate, say \yap{irel/1}, which checks if such a relation is
valid for the list of arguments given as parameter.
%
The modes of each parameter can be given for the input terms and also
for any output answer. The language also allows stating the number of
answers of a predicate.
%
Last, the user may state invariant properties that should hold both
before and after the predicate is executed.
%
\begin{code}
parameter relation
  irel([A1,...,An])
mode
  i(Mi1,...,Min), [o(Mo1,...,Mon)]
range
  {Min,Max}
pre/post conditions
  Goal
\end{code}
Next, we discuss the main properties that we allow in our framework.

\subsection{Types}

We define a type as follows: 

\begin{definition}
\label{def:type}
A {\em type} is a non-empty set of terms.\\
A term $t$ belongs to a type $\tau$ ($t \in \tau$) if it belongs to the set of
terms that define the type.
\end{definition}


% vsc: refer prior work on generative types in Prolog?
% coa: I do not know anything about that, if it fits here I will not be against
Types are not defined as a set of \emph{ground} terms but rather by
the set of terms produced by a generator.
%
These are the types used in predicate specifications where they are
the only mandatory part of the specification.
%
Types are mandatory in order to guarantee that the specification may be
automatically tested.
%
Note that types defined in this manner depict perfectly possible forms of
predicate input.
%
This approach for types already encloses, by domain definition, the type
precondition.


The types mentioned in a predicate specification clause are \plqc{}
generators used to automatically create individual test cases.
%
This means that the type in a specification clause is partial in the
sense that it only specifies the predicate should succeed when given
elements of such types as parameters.
%
It states nothing about parameters of other kinds.
%
Other input types can be covered by other specification clauses with
different generators.
%
The effect of a procedure execution for types not covered by any of the
specification clauses is considered undefined.


\subsection{Domain}

Correct typing of parameters is crucial but may be insufficient to
express the allowed input.
%
Sometimes the arguments must obey a relation extending type information,
based on the actual values of the parameters.
%
The domain of a predicate is the set of parameters accepted by a
predicate.
%
The domain precondition is a restriction over the set of parameters of a
predicate.


\begin{definition}
\label{def:domain}
A {\em domain} of a procedure p/n is a set of term
n-tuples such that\\
\qquad $\langle t_1,...,t_n \rangle \in (\tau_1 \times ... \times
\tau_n)$\\
\qquad $\langle t_1,...,t_n \rangle$ satisfies the input parameter relation
\end{definition}


This definition of a domain, similarly to what happens with types, is
different from the regular notion of domain.
%
It focus on the shape of the input to a predicate and not the accepted
answer set.
%
The \plqc{} domain of a predicate is then any set of terms produced by
the generator that fulfils the domain precondition.
%
In the absence of a domain precondition relating parameters the domain
is the set of terms generated.


\subsection{Directionality}

The directionality of a predicate describes its possible uses by
specifying the possible forms of the parameters before and after
execution.
%
The main modes for a parameter are ground, variable and neither ground
nor variable.
%
Conjunction of modes is also possible and all combinations are achieved
by the notation for ground and variable as well as the negation:
\emph{g}, \emph{v} and \emph{n\_}.
%
This results in the main modes and their pairwise combinations: \emph{g},
\emph{v}, \emph{ngv},  \emph{ng}, \emph{nv}, \emph{gv}.
%
A parameter that can be used in any form is denoted by the mode
identifier \emph{any}.


\begin{definition}
\label{def:modes}
The \emph{modes} or \emph{forms} a term may present are denoted by\\
 $Modes = {g, v, gv, ng, nv, ngv, any}$
\end{definition}


There are two components to a directionality: input and output.
%
They must hold for a predicate's parameters before and after execution,
respectively.
%
This means a full directionality denotes a pre- and a post-condition to
the execution of the specified predicate.
%
In \plqc{} these properties are checked for each test case when
specified before and after calling the predicate, accordingly.


Input directionality acts as a sanity check for the elements of the
domain, meaning that the generators must be constructed to conform to the
specified input modes.
%
Each specification clause is allowed one input directionality.
%
If the user wishes to specify more than one input form the clause should
be divided into the number of input forms and its generators adapted
accordingly.
%
This results in bigger predicate specifications with possibly many
duplicated parts, but is a very simple way to express what happens to the
parameters in finer detail.


Each input may have more than one answer and therefore more than one
output form.
%
For this reason we adopted the schema where an input directionality is
paired with a list of output forms.


\begin{definition}
\label{def:directionality}
A \emph{directionality} of a specification clause of a predicate
\yap{p/n} is a sequence of \emph{predicate modes}, with one input mode
followed by one or more output modes.
\\
A predicate mode of \yap{p}, or just mode of \yap{p}, is a denoted as
\begin{itemize}
  \item $i(m_1, ..., m_n)$
  \item $o(M_1, ..., M_n)$
\end{itemize}
where $m_i,M_i \in Modes$ and $i, o$ respect to input and output modes
respectively.
\end{definition}


\todo{talk a little about inconsistent directionalities ($v<ngv<g$),
  which are only caught during testing...}
\todo{maybe also about minimality and how we just don't care, we test}

\subsection{Multiplicity}
The number of answers a predicate call has can also be valuable
information.
%
Knowing a predicate has a finite search space is a termination
guarantee for predicates using it.
%
Conventionally, multiplicity information, or \emph{range}, is given for
each directionality~\cite{somogyi1995mercury}.
% vsc: mercury
% coa: this ref? 
%
In \plqc{} we do not require that a directionality is given, in which
case no tests are performed regarding parameter form and the \emph{any}
mode is assumed for all parameters.
%
The multiplicity is tied to the domain of each specification clause
where defined.


The range of answers is given with two bounds: \emph{Min} and
\emph{Max}.
%
These values are the lower and upper bounds to the number of answers.
%
The lower bound should not exceed the upper bound and they both take
non-negative integer values up to infinity (denoted by the atom
\yap{inf}).
%
When no explicit multiplicity is given the default we chose to follow is
$\langle 1, inf \rangle $.
%
When testing a specification clause, the default minimal expected
behaviour is that the domain is successfully accepted by the predicate.
%
Therefore we tried to mirror this when there are other features
specified but no multiplicity, expecting at least one solution.


It is necessary to impose a limit when the upper bound is infinity or an
excessively large number.
%
One can state the maximum number of answers necessary to assume that the
answer range is sufficiently close to the upper bound with a positive
integer.

\subsection{Properties}

Along with all the other features of a predicate we can have a
connection between the relations represented by the predicate being
specified and other predicates.
%
These relations can be valid prior to or after execution.
%
In the predicate specification language they are pre- and
post-conditions and are expressed as \plqc{} properties.


A pre-condition is a property that does only inspects its input.
%
It does not change the generated values to be applied to the specified
predicate.
%
Post-conditions can use also use any of the specified parameters.
%
Since they are no longer used, it does not matter if they are changed.
