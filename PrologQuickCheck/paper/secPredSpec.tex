% -*- mode: latex; mode: folding -*-

\section{Predicate Specification}
\label{sec:pred-spec}

Here we describe our predicate specification language following some of
the principles in.
\todo{cite Yves Deville's ``logic programming''}
%
There are several ways to state a predicate's specification, we do not
declare our specification process to be superior to others in any way.
%
It is just a form to express some predicate features we thought to be of
importance in a way that suited our needs.


Our general specification form of a predicate \yap{p/n} consists, in its
core, of a set of specification clauses about input types.
%
\begin{code}
predicate specification clause
  p Id
parameter input types
  T1, ..., Tn
\end{code}
%
Various aspects of the predicate for the particular input type in
question can be added to a specification clause.
%
\begin{code}
parameter relation
  irel([A1,...,An])
mode
  i(Mi1,...,Min), [o(Mo1,...,Mon)]
range
  {Min,Max}
pre/post conditions
  Goal
\end{code}


\subsection{Types}

As mentioned in \refSec{sec:generators}, types in \plqc{} differ from
the regular notion of type.
%
Our types are not defined by a set of \emph{ground} terms but rather by
the set of terms produced by a generator.
%
These are the types used in predicate specification and are also
the only mandatory part of the specification.
%
The reason for this is the goal of the specification, which is to be
automatically tested.
%
Types defined in this manner depict perfectly possible forms of
predicate input.
%
This approach for types already encloses, by domain definition, the type
precondition.


\begin{definition}
\label{def:type}
A {\em type} is a non-empty set of terms.\\
A term $t$ belongs to a type $\tau$ ($t \in \tau$) if it belongs to the set of
terms that define the type.
\end{definition}


The types mentioned in a predicate specification clause are \plqc{}
generators used to automatically create individual test cases.
%
This means that the type in a specification clause is partial in the
sense that it only specifies the predicate should succeed when given
elements of such types as parameters.
%
It states nothing about parameters of other kinds.
%
Other input types can be covered by other specification clauses with
different generators.
%
The effect of a procedure execution for types not covered by any of the
specification clauses is considered undefined.


\subsection{Domain}

The domain of a predicate is the set of parameters accepted by a
predicate.
%
Correct typing of parameters is crucial but may be insufficient to
express the allowed input.
%
Sometimes the arguments must obey a relation extending type information,
based on the actual values of the parameters.
%
The domain precondition is a restriction over the set of parameters of a
predicate.


\begin{definition}
\label{def:domain}
A {\em domain} of a procedure p/n is a set of term
n-tuples such that\\
\qquad $\langle t_1,...,t_n \rangle \in (\tau_1 \times ... \times
\tau_n)$\\
\qquad $\langle t_1,...,t_n \rangle$ satisfies the input parameter relation
\end{definition}


This definition of a domain, similarly to what happens with types, is
different from the regular notion of domain.
%
It focus on the shape of the input to a predicate and not the accepted
answer set.
%
The \plqc{} domain of a predicate is then any set of terms produced by
the generator that fulfils the domain precondition.
%
On the absence of a domain precondition relating parameters the domain
is the set of terms generated.


\subsection{Directionality}
The directionality of a predicate describes its possible uses by
specifying the possible forms of the parameters before and after
execution.
%
The main modes for a parameter are ground, variable and neither ground
nor variable.
%
Conjunction of modes is also possible and all combinations are achieved
by the notation for ground and variable as well as the negation:
\emph{g}, \emph{v} and \emph{n\_}.
%
This results in the main modes and their pairwise combinations: \emph{g},
\emph{v}, \emph{ngv},  \emph{ng}, \emph{nv}, \emph{gv}.
%
A parameter that can be used in any form is denoted by the mode
identifier \emph{any}.


\begin{definition}
\label{def:modes}
The \emph{modes} or \emph{forms} a term may present are denoted by\\
 $Modes = {g, v, gv, ng, nv, ngv, any}$
\end{definition}


There are two parts of a directionality: input and output.
%
They must hold for a predicate's parameters before and after execution
respectively.
%
In \plqc{} these properties are checked for each test case when
specified.


Input directionality acts as a sanity check for the elements of the
domain, meaning the generators must be constructed to conform to the
specified input modes.
%
Each specification clause is allowed one input directionality.
%
If the user wishes to specify more than one input form the clause should
be divided into the number of input forms and its generators adapted
accordingly.
%
This results in bigger predicate specifications with possibly many
duplicated parts, but is a very simple way express what happens to the
parameters in finer detail.


Each input may have more than one answer and therefore more than one
output form.
%
For this reason we adopted the schema where an input directionality is
paired with a list of output forms.


\begin{definition}
\label{def:directionality}
A \emph{directionality} of a specification clause of a predicate
\yap{p/n} is a sequence of \emph{predicate modes}, with one input mode
followed by one or more output modes.
\\
A predicate mode of \yap{p}, or just mode of \yap{p}, is a denoted as
\begin{itemize}
  \item $i(m_1, ..., m_n)$
  \item $o(M_1, ..., M_n)$
\end{itemize}
where $m_i,M_i \in Modes$ and $i, o$ respect to input and output modes
respectively.
\end{definition}


\subsection{Range}
\subsection{Properties}

