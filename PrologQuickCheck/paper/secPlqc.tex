% -*- mode: latex; mode: folding -*-

% should first explain quickcheck and random arguments

\section{Properties}
%% \section{\plqc{} Properties}
\label{sec:properties}

The main idea of property-based testing is to extend with property definitions
program code.
%
Properties are specifications in a suitable language.
%% Properties are specifications in a custom language or in a programming
%% language.
%
For example, in \QuickCheck{} properties are \Haskell{} functions such as:
%
\begin{code}
 prop_pos_square :: Int -> Bool
 prop_pos_square x = x*x >= 0
\end{code}

Properties are then tested by an automatic tool.
%
Again for \Haskell{} \QuickCheck{} that would only be a call:
%
\begin{code}
 >> quickCheck prop_pos_square
 +++ OK, passed 100 tests..
\end{code}
%
This tests the \emph{positive square} property in 100 randomly
generated cases.
%% \todo{comentario perguntava se 'generated cases' eram inteiros e sao; é
%%   para fazer a substituição 'cases'->'integers'}
%
The input for the property is generated based on its type by
\QuickCheck{} through type machinery.
%
The test data generators are tied to a specific type and randomly pick a
value from that type.


\plqc{} is a property-based testing framework.
%
% vsc: define what property is first:
Properties are logical statements that specify the behaviour of or the relation between software
elements.
%% Properties are logical statements about software.
%% %
%% They specify the behaviour of or the relation between software
%% elements.
%% %
%% Properties are observable inside the language in order to automate the testing process.
%% In order to automate the testing process these are observable properties
%% inside the language.
%
The tool automatically generates input for the properties to be tested
and executes them to assess their validity.
%
A primitive property is a %% n arbitrary
\Prolog{} goal (hence, the whole
language can be used to define properties).
%
Properties can be composed according to composition
rules described in the continuation.
%
%% In the latter case the \plqc{} tool recursively inspects
%% properties according to the composition rules.
%
% vsc: define the composition rules: anything goes?
% coa: later?
%
%% The expressive power of properties is thus the same as \Prolog{}
%% predicates.
%
This enables the specification of a wide range of properties about
predicates through the use of meta-predicates, such as checking
the mode of a goal. % coa: here I was thinking of ground(X) and var(Y);
                    % isn't this the mode of a term?
%
Next, in this section we discuss in detail an example of how to define
properties in \plqc{}.


The example is a predicate to reverse lists.
%
We assume the existence of a predicate \yap{rev/2}, relating two lists
with reversed element order.
%
The property and predicate to be tested are in %% the same
module%% ,
 \yap{m}.%% , and %% will
%% have access to the \plqc{} tool module.
%
The \yap{rev/2} predicate has a set of desired behaviours, which
correspond to the laws of a reversing operation (where |++| 
represents list concatenation).%% (we use |++| to
%% represent composition of lists).
%
Using a functional notation:
%% \todo{era para por esta ultima frase em novo paragrafo?}
{
\aligncolumn{10}{@@{}>{\hspre}r<{\hspost}@@{}}
\aligncolumn{12}{@@{}>{\hspre}r<{\hspost}@@{}}
\begin{code}
(1)        rev([])     == []
(2)     rev(XS++YX)    == rev(YS) ++ rev(XS)
(3)      rev(rev(XS))  == XS
\end{code}
}
These laws are intended to be satisfied for ground, finite lists
\yap{XS} and \yap{YS}.
%
We can represent
 them as conjunctions of \Prolog{} goals. %%  such as the following for the
 %% third law:
For the third law we have:
%%  the above properties as conjunctions of \Prolog{}
%% goals:
%
%% \begin{yapcode}
%%   (1)  rev([], [])
%%   (2)  append(XS, YS, ZS), rev(ZS, RZ),
%%         rev(XS, RX), rev(YS, RY), append(RY, RX, RZ)
\begin{yapcode}
  (3)  rev(XS, RX), rev(RX, XS)
\end{yapcode}
%
%% Note that v
Verifying the properties for a certain input consists of
executing the code. %% in a \Prolog{} interpreter.
%
%% Moreover, n
Note that this property can have multiple meanings
depending on its parameter modes.
%
In this particular case we want to express the symmetry of the
\yap{rev/2} relation in terms of its intended use: given a ground
list in one argument retrieve a result in the other.


The next step is optional.
%
We explicitly parametrise the property into a first order object.
%% The idea is to generalise the goal.%% , give it the desired label and parametrise it accordingly.
%
\begin{yapcode}
 pcprop({dr, XS}) :- rev(XS, RX), rev(RX, XS).
\end{yapcode}
%
%% Note that the generalised call
The resulting property
is  written as a clause for the special
predicate \yap{pcprop/1} and parametrised accordingly.
%
This is \plqc{}'s predicate for labelling properties.
%
The body of labelled properties is inspected by \plqc{},
%% When a call to this predicate is found during testing, \plqc{} inspects
%% the body of the clause, 
making it possible to abstract long or
frequently used properties.%%  and compose complex properties from smaller
%% elements.


A last step is needed %% We need to perform a last step
to verify properties with \plqc{}.
%
In order to enable random testing, we
define a domain for parameter instantiations.
%% need to specify the set of values over which we abstract the property.
Values from this domain are used as test cases.
%% \todo{continuo a nao gostar destas frases, a ligação entre 'parameter
%%   instantiations' e 'test cases' nao esta no ponto...}
%
\begin{yapcode}
 pcprop(d_rev) :- pcforall(listOf(int), XS, pcprop({dr, XS}))
\end{yapcode}
%% \begin{yapcode}
%%  pcprop(d_rev) :-
%%    plqc:pcforall(listOf(int), XS, m:pcprop({dr, XS}))
%% \end{yapcode}
%


This more precise definition %% says that we want to test our \yap{dr}
states that the property \yap{d_rev} is \yap{dr}
over lists of integers.% \yap{XS}.
%
More precisely, we use \yap{pcforall/3} to represent \plqc{}'s universal quantification.
%
The first argument describes the \emph{type} of terms we want to
generate randomly, in this case lists of integers,
\yap{listOf(int)}.
%
The second argument names the variable of interest, in this case \yap{XS}.
%
The third %% names
is
the property we want to verify.
%
%
%% Next, we can
To
check the property.
%
%% This is done by calling
we can call
 \plqc{} using the alias
\yap{pcprop(d_rev)} to define the property.
%% \yap{m:pcprop(d_rev)} to define the property.
\begin{yapcode}
   ?- prologcheck(m:pcprop(d_rev)).
 OK: Passed 100 test(s).
\end{yapcode}
%% \begin{yapcode}
%%    ?- plqc:prologcheck(m:pcprop(d_rev)).
%%  OK: Passed 100 test(s).
%% \end{yapcode}
%%  yes
%% \end{yapcode}
%
The \yap{prologcheck/1} predicate is the simplest property tester in
\plqc{}, taking a property as a parameter and checking it for a large
number (100 is the default number) of generated test cases.
%
We use a generator such that test cases are randomly generated from
terms up to a maximum term size.
%% %
%% This is due to the fact that test cases are randomly generated based on
%% a maximum term size.

We could have %% made a mistake and
mis-typed the property, %% which would deem
making
it impossible to be satisfied:
%
\begin{yapcode}
 pcprop(wrong_dr) :-
   pcforall(listOf(int), XS, (rev(XS,RX), rev(RX,RX))).
\end{yapcode}
%
%% Here we
We mistakenly make the second call to \yap{rev/2} with \yap{RX} as
the second parameter.
%
\begin{yapcode}
   ?- prologcheck(m:pcprop(wrong_dr)).
 Failed: After 11 test(s).
 Shrinking (6 time(s))
 Counterexample found: [[0,6]] 
\end{yapcode}
A counterexample is found and showed in a list of generated input
values.
%
In this example it is %% just
a list with four elements.%% , but it can show
%% the sequence of values instantiated in each universal quantification of
%% the property.
%
We observe at this point that a counterexample is only found
after trying several tests.
%
The size criteria causes it to be more likely to get lists with 0 or 1
element early-on, and these small lists trivially obey the property.
%
When the counter-example is found the tool successfully tries to shrink
it and presents a smaller result.


%% Available property operators currently include conjunction
%% Property operators currently available in \plqc{} include conjunction
Property operators currently  include conjunction
 (\yap{Prop1 pc_and Prop2}), disjunction (\yap{Prop1 pc_or Prop2}), conditional
execution (\yap{pcif(Cond, Porp1, Prop2)}) and quantification
(\yap{pcforall(Gen, Var, Prop)}).
%
%% \begin{yapcode}
%%    Prop1 pc_and Prop2
%%    Prop1 pc_or Prop2
%%    pcif(Cond, Porp1, Prop2)
%%    pcforall(Gen, Var, Prop)
%%    pcprop(Label)
%% \end{yapcode}
%
Quantification is explained in the example presented in this section.
%
Property labelling (\yap{pcprop(Label)}) is also %% considered
an operation.
%
%% It has no real effect on the labelled property, but is at the level of
%% composed properties in the sense that it has an effect in the tool.
%
\plqc{} inspects its body for the occurrence of other tool specific
operations.


Conjunction and disjunction of properties is used %% in the place where
%% conjunction and disjunction of goals is expected.
as expected.
%
%% The main difference is that \plqc{} descends on the structure of
%% properties and not on the structure of goals.
%
Using property connectives one can compose labelled properties or %% any
other \plqc{} property operations.
%


The conditional \yap{pcif/3} has a similar behaviour to its ISO
\Prolog{} counterpart, but at the level of \plqc{} properties.
%
It enables conditional properties without cut, which would not be
coincident with its semantics in \Prolog{} goals.



%% We can freely compose \Prolog{} goals as properties.
%% %
%% These goals' content is not inspected by the tool.
%% %% These goals are indivisible and the tool does not inspect their content.
%% %
%% Namely, we can make logical statements with built-in control predicates:
%% truth values (\yap{true} and \yap{fail}), conjunction (\yap{Goal1, Goal2}), disjunction (\yap{Goal1; Goal2}), implication (\yap{Goal1 -> Goal2}) and negation (\yap{\+(Goal)}).
%% %
%% \begin{yapcode}
%%    true
%%    fail
%%    Goal1; Goal2
%%    Goal1, Goal2
%%    Goal1 -> Goal2
%%    \+(Goal)
%% \end{yapcode}
%% %
%% Other control predicates, such as cut (\yap{!}), are also allowed.%%  in
%% %% order to refine the meaning of a property.
%% %
%% Extreme care is advised %% when choosing
%% using
%% goals containing impure or
%% meta-predicates for properties.
%% %
%% For example, a \emph{cut} only affects the primitive
%% property it is inserted in, not the whole property.
%% %% For example, when applying a cut this only affects the primitive
%% %% property it is inserted in, not the whole property.
%% %


Primitive properties are \Prolog{} goals.
%% \todo{esta frase ja nao ficou grande coisa... amanha ha mais}
%% In a setting with a strong static type system one can ensure that
In a strongly typed language (such as \Haskell{}))
only
safe properties, pure functions or predicates, are allowed.
%
%% But this is not the case in \Prolog{}.
%
%% If we want \plqc{} to be able to inspect the structure of a property
%% it has to be composed with \plqc{} operators.
%
%% We choose to let the user be
In \plqc{} the user is
free to use simpler or more involved
properties.
%
This provides extra flexibility but, ultimately, the user
is %% the one
responsible for guaranteeing that the impure code in a property
%% is self-contained and thus
does not interfere with posterior test
cases and is not influenced by previous ones.
%% \todo{comentario talvez diga para colocar algo do tipo ' we jsjdjdsj to
%%   the user' antes de 'the user is responsible'}


\section{Generators}
\label{sec:generators}

Input for testing properties is randomly generated through an explicitly
defined procedure.
%
We saw a reference to \yap{listOf(int)} in the previous example.
%
This is an example of a \emph{generator} in \plqc{}.




There are  differences between \plqc{} generators and the
generators in a strongly typed version of the tool.
%
In \Haskell{} \QuickCheck{}, or any language with strong types,
generators pick values inside a type according to some criteria.
%
In \plqc{} generators represent procedures that randomly choose an element
from a set of values.
%% \todo{geradores nao sao predicados reais, mudei de forma a dizer que
%%   representam procedimentos}
%
In fact, the generators themselves define the set by the elements
they generate, with non-zero probability.
%
Thus, they define a set of terms and therefore a \emph{type}.
%% \todo{ha por aqui um comentario que parece ter 'as', algures por estas bandas}
%
Note that this set of terms is not necessarily composed of only ground
terms, instead it
%% is supposed to
 exactly represents
the form of an input parameter to a
property.


In \plqc{} we differentiate between generators and generator
predicates.
%
A generator is based on the notion of closure, it is an incomplete
parametrisation of the corresponding generator predicate.
%
The bridge between the generator and the corresponding generator
predicate is %% made by
\plqc{}'s quantification.
%
A generator is any callable term that can generate a value given a
size parameter.
%
%% The bridge code
\plqc{} 
calls the generator with two extra
arguments: the quantified variable and the current size parameter.
%
The generator predicate can use the size to guide value
construction.
%
The value is passed to the property by the \plqc{} quantification
through unification.


\begin{yapcode}
 generator_predicate(A1,...,An,Value,Size).
\end{yapcode}
%% \todo{acredito que os hieroglifos diziam para mudar a representacao de
%%   'generator\_predicate' para o inicio do paragrafo}
%
Together with the generator predicates for fundamental sets of values, we %% make
%% available
provide
 generator combinators to construct more complex
generators.
%
Generator predicates can have multiple parameters in order to build
values, but the two last arguments must always be, in this order, the
generated value and the size.
%
When a generator predicate uses another generator predicate to build a
value, the parameter passed is in generator form.
%
This is shown in the example,
where the generator for lists, \yap{lisstOf(int)}, is parametrised by a
generator for the integers.


\paragraph{\bf Combinators}
%% \subsection{Combinators}

\plqc{}'s supports generator combinators, these are generator predicates that are
parametrised by other generators.
%
They are used to build generator predicates for complex data and to
adjust the probability distribution of a generator to fit the needs of
the tester.
%
%% Follows a list with some of the
Next, we present some
combinators distributed with the tool.
%% \todo{acredito que para esta ultima frase o comentario tem 'present'}


During testing, the tool keeps a record of the size parameter, which
increases with each test case.
%
This way, it is more likely to find smaller and more readable
counter-examples if they exist.
%% \todo{segunda frase para responder ao porquê do tamanho aumentar}
%% \todo{também acaba por ser mais eficiente, porque gerar e executar casos
%% grandes vai ser (quase) sempre mais custoso}.
%
If the values or part of the values to be generated have to be of a
certain size, we override this parameter with the \yap{resize/4}
combinator.
%
\begin{yapcode}
 resize(NewSize, GenA, A, _Size) :- call(GenA, A, NewSize).
\end{yapcode}


Picking an integer in an interval is probably the most common operation
in generators.
%
The \yap{choose/4} predicate discards the size parameter and randomly
chooses an integer between the inclusive range given by the first two
arguments.
%
\begin{yapcode}
 choose(Min,Max, A, _) :- Cap is Max+1, random(Min,Cap,A).
\end{yapcode}


We can restrict the values of a generator. %% by some predicate.
%
If not all generated elements for a generator are useful, wrapping it
with \yap{suchThat/4} will select the elements of the generator in the
first argument that satisfy the predicate in the second.
%
\begin{yapcode}
 suchThat(GenA, PredA, A, S) :- suchThatMaybe(GenA, PredA, A, S), !
   ; stSizeStep(S, S1), suchThat(GenA, PredA, A, S1).
\end{yapcode}
%
If a generated value is valid, given by a successful call to
\yap{suchThatMaybe/4}, it is returned; if not, the size parameter is
slowly increased to avoid a size without valid values.
%
This is a dangerous combinator in the sense that it can loop
indefinitely  if the the valid values %% generated
are too sparse.
%% \todo{'loop' tinha rabiscos - nao percebi}
                                                        

Often, it is hard to find a good generator.
%
Many times, choosing from a set of generators that complement each other
is the best way to generate values with a good distribution.
%% \todo{'many' sublinhado e um 'and' por cima... nao estou a perceber}
%
Grouping generators can be done in several ways.
%
We can randomly choose from a list of generators with \yap{oneof/3}.
%
The list of generators given in the first argument must be non-empty.
%
\begin{yapcode}
 oneof(LGenA, A, S) :- length(LGenA, Cap), choose(1,Cap,I,S),
   nth(I, LGenA, GenA), call(GenA, A, S).
\end{yapcode}
%
If a uniform distribution between the generators is not suitable one can
specifically state the proportions of the probabilities to choose each
generator.
%
The first argument of \yap{frequency/3} is a list of pairs
\yap{\{}\emph{weight}\yap{,}\emph{generator}\yap{\}} representing such
proportions.
%
The input list must also be non-empty.
%
A frequency-index list is created with the correct proportions and a
generator is then randomly chosen from that list to be called.
\begin{yapcode}
 frequency(FGL, A, S) :- checkFreqWeights(FGL, FIL, Cap),
   choose(1,Cap,I,S), nth(I, FIL, GenA), call(GenA, A, S).
\end{yapcode}

 %% checkFreqWeights([], [], 0).
 %% checkFreqWeights([{W,Gen}||FGS], FIL, Cap) :-
 %%   checkFreqWeights(FGS, FIL1, Cap1),
 %%   addHeads(W,Gen, FIL1, FIL),
 %%   Cap is Cap1 + W.

 %% addHeads(0, _Gen, L, L) :- !.
 %% addHeads(K, Gen, LI, LO) :-
 %%   K1 is K-1,
 %%   addHeads(K1, Gen, [Gen||LI], LO).


Generator predicate \yap{elements/3}, similarly to what
\yap{oneof/3} does to generators, randomly chooses an element%%  to
%% generate
from a non-empty list of possible elements.
%
\begin{yapcode}
 elements(AS, A, S) :-
   length(AS, Cap), choose(1,Cap,I,S), nth(I, AS, A).
\end{yapcode}



To generate lists we provide generators for arbitrary and
fixed length lists.
%
They are %% all
parametrised by a generator for the list elements.
%
Random size lists can be generated by \yap{listOf/3}, which randomly
chooses a list length and uses \yap{vectorOf/4}. 
%
\yap{vectorOf/4} is a fixed length generator predicate that recurs on
the integer given as the first argument, generating
%% chooses a list length and uses the \yap{vectorOf/4} fixed length
%% generator predicate.
%% %
%% The latter recurs on the integer given as the first argument, generating
list elements until the list has enough elements.
\begin{yapcode}
 listOf(GenA, AS, S) :- choose(0, S, K, S),vectorOf(K, GenA, AS, S).

 vectorOf(0, _GenA, [], _Size) :- !.
 vectorOf(K, GenA, [A||AS], Size) :-
   call(GenA, A, Size), K1 is K-1, vectorOf(K1, GenA, AS, Size).
\end{yapcode}


Generating specific values, ground or not, fresh variables and terms
with a certain structure is also possible with \yap{value/3},
\yap{variable/2} and \yap{structure/3} respectively.
%
\begin{yapcode}
 value(A, A, _Size).

 variable(X, _Size) :- var(X).

 structure(X, Y, Size) :- var(X), !, var(Y), X=Y.
 structure([], [], Size) :- !.
 structure([SX||SXS], [X||XS], Size) :-
   !, structure(SX, X, Size), structure(SXS, XS, Size).
 (...)
 structure(GenX, X, Size) :- call(GenX, X, Size).
\end{yapcode}


%% To build a generator that only produces a certain value, ground or not,
%% we use \yap{value/3}, giving the element as the first argument.
%% %
%% If a fresh variable is needed, one can use the \yap{variable}
%% generator.
%% \begin{yapcode}
%%  value(A, A, _Size).

%%  variable(X, _Size) :- var(X).
%% \end{yapcode}
%% %
%% In the case where we want to generate values with a certain fixed
%% structure with random parts we can use \yap{structure/3}.
%% %
%% This generator predicate descends on the structure of the first
%% argument, list or tuple, replicating it for the generated value.
%% %
%% When reaching a leaf-pattern, it evokes the generator found and
%% uses the leaf-value generated to construct the the output value.
%% %
%% \begin{yapcode}
%%  structure(X, Y, Size) :- var(X), !, var(Y), X=Y.
%%  structure([], [], Size) :- !.
%%  structure([SX||SXS], [X||XS], Size) :-
%%    !, structure(SX, X, Size), structure(SXS, XS, Size).
%%  (...)
%%  structure(GenX, X, Size) :- call(GenX, X, Size).
%% \end{yapcode}
%%  %% structure({ST}, {T}, Size) :-
%%  %%   !,
%%  %%   structure(ST, T, Size),
%%  %%   structure(SXS, XS, Size).
%%  %% structure( (SX, SXS), (X, XS), Size) :-
%%  %%   !,
%%  %%   structure(SX, X, Size),
%%  %%   structure(SXS, XS, Size).


\paragraph{\bf Shrinking}

When a test fails the tool may try to shrink the failing input to a
smaller and easier to understand counterexample.
%
Shrinking is a process by which a \emph{shrinker} predicate returns a
possibly empty list of smaller elements than the one given as input.


Similarly to generator predicates, shrinkers are calls to the
corresponding generator.
%
To trigger shrinking a generator is called with the value to shrink, the
flag \yap{shrink} and a variable to store the list of shrunk values.
%
An example of a shrinker behaviour for lists is to remove an
element.
%
The following auxiliary predicate builds a list of the possible shrunk
lists.
%
\begin{yapcode}
 genL(GenA, L, shrink, Shrs) :-  shrL(L, Shrs).
 shrL([], []).
 shrL([A], [[]]) :- !.
 shrL([A||AS], [AS||Shrs]) :-
   shrL1(AS, Shrs1), maplist(cons(A), Shrs1, Shrs).

 cons(X, XS, [X||XS]).
\end{yapcode}


Most combinators do not have a default shrinking procedure.
%
Since it is hard to decide, for example, what is a proper shrink for
values generated by a random choice between generators, we %% have
default
the shrinking of many combinators to an empty list of shrunk values.
%
Instead of directly using combinators in a property quantification
the user can wrap them in a generator predicate with a meaningful name,
implementing the shrink behaviour for this specific type.
