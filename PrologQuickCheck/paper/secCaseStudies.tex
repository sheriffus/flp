% -*- mode: latex; mode: folding -*-

\section{Case Studies}
\label{sec:case-studies}

\subsection{List Processing}
We started to write small predicates and specifications along with the
tool development.
%
These small examples turned out to be interesting to show some of the
potential of \plqc{}.
%
They helped to reveal discrepancies between intended and actual
behaviour of the predicates.
%
The tool is specially useful for people that are beginning logic
programming or have their logic programming polluted by other
programming styles, such as one of the authors.


%{{{ List Reverse

\subsubsection{List Reverse}
Here we return to the first example given in \refSec{sec:properties}.
%
In general people have a conception of what is reversing the order of
elements, which is to observe the $i^th$ element of the original list as
the $(1+n-i)^th$ element of the reversed one for a list of size $n$.
%
There is also the idea of how to code such a procedure, independently of
the programming language.
%
In fact, there are quite a few ways to implement it and we played with
some implementations of the procedure.


What we intend to check about our reverse procedures is the ability to
transform an input list into its reversed counterpart.
%
This implies that the property has an input for random testing.
%
For the automatic generation of input we must decide what is the input.
%
When a procedure is polymorphic on the type of the elements of an
argument list it is usually sufficient to check its behaviour for a
single type of elements.
%
It is sometimes sufficient a finite number of values, but we can
safely overestimate the size of the type.
%
We choose to test the list predicates with lists of integer elements.
%
Therefor we use the generator for integers, \yap{int}, with the
parametric list generator, \yap{listOf(int)}.


We start with two implementations of reverse.
%
The first uses an appending predicate, described later, and the second
builds the result with an accumulator via an auxiliary predicate.
%
\begin{yapcode}
 rev_app([],[]).
 rev_app([X||XS], YS) :-
   rev_app(XS,ZS), append(ZS, [X], YS).

 rev_acc([], LR, LR).
 rev_acc([X||XS], Acc, LR) :-
   rev_acc(XS, [X||Acc], LR).

 rev_acc(L, LR) :-
   rev_acc(L, [], LR).
\end{yapcode}


We can adapt the properties in \refSec{sec:properties} to both versions.
%
We do it by identifying the property names and called predicates
appropriately.
%
For the \yap{rev_app/2} predicate we have.
\begin{yapcode}
 qcprop(double_rev_app) :-
   plqc:qcforall( listOf(int), L,
     mod:qcprop({double_rev_app_body, L})).

 qcprop({double_rev_app_body, L}) :- 
   mod:rev_app(L, LR),
   !, % enforce first solution
   mod:rev_app(LR, L2), !, L == L2.
\end{yapcode}
%
The version for \yap{rev_acc/2} is obtained by changing the affix of
identifiers from \yap{app} to \yap{acc}
%
Both properties underwent testing, passing all given tests.
%
%   ?- plqc:quickcheck(plqccase1:qcprop(double_rev_app), [{numtests, 1000}]), plqc:quickcheck(plqccase1:qcprop(double_rev_acc), [{numtests, 1000}]).
\begin{yapcode}
   ?- plqc:quickcheck(
          (mod:qcprop(double_rev_app))
        qcand (mod:qcprop(double_rev_acc)),
          [{numtests, 1000}]).
 OK: Passed 1000 test(s).
 yes
\end{yapcode}


To check that the order is being reversed we can randomly choose an
element (or even a random set of elements) and inspect if it is
correctly positioned in the reversed list.
%
Choosing random elements prevent us from checking the whole list.
%
\begin{yapcode}
 qcprop(rev_app_index) :-
   plqc:qcforall(
     suchThat(structure({listOf(int), int}),
       plqccase1:valid_index),
     {L,I},
     mod:qcprop({double_rev_index_body, L, I})
   ).
 valid_index({L, I}) :-
   length(L,X), I<X.

 qcprop({double_rev_index_body, L, I}) :- 
   mod:rev_app(L, LR),
   length(L,X),
   Index is I+1, RevIndex is X-I,
   lists:nth(Index, L, Val),
   lists:nth(RevIndex, LR, Val).
\end{yapcode}
%
When performing a large number of tests this method should give good
element coverage.
%
\begin{yapcode}
   ?- plqc:quickcheck(
        mod:qcprop(rev_app_index),
        [{numtests, 1000}]).
 OK: Passed 1000 test(s).
 yes
\end{yapcode}


But since we have two implementations of the same concept we can explore
this by only performing tests on one version and stating a property
comparing their behaviours.
%
\begin{yapcode}
 qcprop(equiv_acc_app) :-
   plqc:qcforall( listOf(int), L,
     (mod:rev_acc(L,LR), mod:rev_app(L,LR))).
\end{yapcode}
The comparison succeeds if both have the same behaviour.
%
\begin{yapcode}
   ?- plqc:quickcheck(
        mod:qcprop(equiv_acc_app),
        [{numtests, 1000}]).
 OK: Passed 1000 test(s).
 yes
\end{yapcode}

%}}}

\subsubsection{Append}
The implementation of the appending predicate recurs on the first list
and the appended list parameters, leaving the second list uninspected.
%
\begin{yapcode}
 append([], YS, YS).
 append([X||XS], YS, [X||AS]) :-
   append(XS, YS, AS).
\end{yapcode}
%
We check the behaviour of the \yap{append/3} predicate
through its specification with the predicate specification language
presented in \refSec{sec:pred-spec}.
%
The most obvious way to use append is by giving it two lists and expect
the resulting appended list.
%
So the type of such a specification clause is
(\yap{listOf(int),listOf(int),variable}).
%
We can assert that, in this \plqc{} type, parameters input modes are
(\yap{ground, ground, var}) and the output modes (\yap{ground, ground,
  ground}).
%
It should also be the case that this use of the predicate behaves as a
function, expecting exactly one answer.
%
\begin{yapcode}
 mod:append
   of_type (A-(plqc:listOf(int)),
     B-(plqc:listOf(int)), C-(plqc:variable))
   where (i(g, g, v), o(g, g, g))
   has_range {1,1}.
\end{yapcode}
%
Quickchecking this specification clause bears no surprises.
%
\begin{yapcode}
   ?- plqc:quickcheck(
        mod:qcprop(spec_append),
        [{numtests, 1000}]).
 OK: Passed 1000 test(s).
 yes
\end{yapcode}


Although \yap{append/3} has an intended usage, it may be successfully
used in other situations.
%
For example, one can use it to create an open list, by giving a variable
in place of the second list, which remains uninspected.
%
The result is a list with the ground elements of the first list and the
second list variable as the tail, therefor it is neither ground nor
variable.
%
This usage also behaves as a function, since the potentially mutating
part of the input is not a target of pattern matches.
%
\begin{yapcode}
 {mod:append, 1}
   of_type (A-(plqc:listOf(int)),
     B-(plqc:variable), C-(plqc:variable))
   where (i(g, v, v), o(g, v, ngv))
   has_range {1,1}.
\end{yapcode}
%
% when L1 is [], LApp is L2, i.e. var
\begin{yapcode}
 {mod:append, 2}
   of_type (A-(plqc:variable),
     B-(plqc:listOf(int)), C-(plqc:variable))
   where (i(v, g, v), o(g, g, g))
   has_range {1,1}.
\end{yapcode}
 % default 1-inf


\subsection{AVL Trees}
\subsection{red-black Trees}



\begin{yapcode}
\end{yapcode}
\begin{yapcode}
\end{yapcode}
