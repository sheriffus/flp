% -*- mode: latex; mode: folding -*-

\section{Introduction}
\label{sec:intro}
%{{{ introduction text

%Narrative: 
%  What (is the subject),
%  why  (are we exploring it) and 
%  how  (are we doing it)

% the Introduction intro, a bit of 'what'
%% The life-cycle, and often the cost, of most sofware systems is
%% dominated by maintenance effort~\cite{wasnik2013software,DBLP:journals/tplp/SerebrenikSD08,swi-prolog}.
%% %
%% Maintenance may include porting a program to new platforms, or
%% adapting the program to unexpected tasks, but most often is about
%% debugging flaws in the original program.
%% %
%% Early detection and
%% correction of bugs is thus crucial to minimize the total maintenance
%% effort and its associated costs.
%% %
%% Ideally, bug detection would be possible by automatic verification
%% against a specification.
%% %
%% High-level languages, such as logic and functional programming languages
%% offer the promise to achieve this ultimate
%% goal~\cite{wadler1989theorems,cortesi1997specification}.
%% %
%% In practice, testing is still necessary and often crucial for bug
%% detection, and thus a fundamental component in software development.
%% %
%%  %, very widely used and with
%% %growing importance in the industry.
%% % coa: could not introduce industry examples in this text, maybe it is
%% %      not needed
%% % \cite{arts2006testing}
%% %
%% Notice that testing is not a one-shot operation in most software.
%% %
%% Regardless of the formal and constructive nature of logic programming,
%% rare cases and typing mistakes make it necessary to regularly test
%% throughout program development.

%  What (is the subject)
Testing a software component, or components, consists of executing it on
a pre-selected set of inputs (test suite) and inspecting whether the outputs
respect the expected results.
%
%% Software testing can be classified by the granularity of test focus, the
%% tester point of view or approach.
%% %
%% Tests can focus on the behaviour of single components (unit testing), the
%% correct interaction of components (integration testing) or that the
%% whole system complies to its specification (system testing).
%% %
%% A library user has its access limited to the given interface in order to
%% test its behaviour whereas the developer may want to check invariants
%% and the integrity of internal data-structures.
%
How to choose the test cases in a test suite is often a difficult
question.
%
The approach used
can be  manual, with the test developer designing test cases one by
one, or it can be automated to some extent, in this case resorting to
tools for case generation.
%
Such tools reduce the time needed for testing software components and make
it easier to test programs being developed.


In this work we introduce \plqc{}, a
property-based testing framework for \Prolog{} inspired on
 \QuickCheck~\cite{quickcheck}.
%
We further present a language for the specification of \Prolog{} predicates
together with a translation procedure for generating \plqc{} properties
based on the specification.


%  why  (are we exploring it) and 
Automatic testing is particularly suitable to logic languages such as
\Prolog{}. The high-level nature of the language makes it easy to
specify test cases.
%
On the other hand, due to its untyped nature the developer may be
oblivious to important corner cases or odd behaviours.
%
Backtracking can also cause unpredicted behaviours in goal conjunctions.
%% Prolog backtracking may also interfere in less than obvious
%% ways, making the run-time behavior elude the programmer.
%
Being able to automatically test a property about a predicate or set of
predicates is thus a clear advantage during software development.
%
\Prolog{}'s ties to logic reduces the gap between the program and the
specification of properties to be tested.
%
Therefore, a property based approach to testing is intuitive for the
logic programmer.


%  how  (are we doing it)
In a property-based framework tests are automatically generated and run from formal specifications of general
properties of the program, and feedback is given to the user about their
evaluation.
%
We implement a randomised test case generation, which frees the user
from choosing input manually.
%
Properties are stated through a domain-specific language wrapping
\Prolog{} goals, which \plqc{} checks for a number of inputs.
%
Singleton properties are pure predicate calls
or composed goals whose successful execution determines that the
property holds for the given input.
%
These properties can be further composed in order to achieve more complex
specifications.


%% %
%% % vsc: this seems too much detail for the Intro
%% %
%% Note that the automatic generation of input for a particular test case of a
%% property is random w.r.t.\ a size parameter for the generated value.
%% %
%% The user has the freedom to decide how to compose the test data
%% generators to best fit the tests' purpose.
%% %
%% From simple generators and using the provided predicate generator
%% combinators it is possible to obtain generators for more complex
%% domains, provide suitable value distributions for specific predicates or
%% predicate usages and to ensure the relation between the arguments applied
%% to the predicates being tested is valid.


%  something different
Since \plqc{} is a tool to test \Prolog{} programs we took advantage of
the nature of the language and loosened the requirements for property
specification.
%
Traditional interfaces rely on built-in mechanisms, such as equality or
a boolean type, to determine primitive properties.
%
Even if they are composed of software units of other types they still
need to be able to evaluate to a truth value in order to assess a
property validity.
%
With \Prolog{} there are no such restrictions: any goal may be a property.
%
Instead of expecting a reduced set of syntactic elements to describe
properties, in \plqc{} a property is a goal or a composition of
properties.
A property is satisfied when the execution of the goal, given all
necessary input, succeeds or the composition rules are met.
%
Input to such goals is given based on \plqc{} value abstraction,
quantification over a domain represented by a term generator.
%
%% Properties can be composed and their validity is defined by the
%% composition operation.
%
Testing will consist on repetitively calling the goal for multiple
potential inputs.


%  overview
%% \plqc{} tool is inspired by \QuickCheck{} and retains its main
%% ideas.
%% %
%% %It is an automatic software testing tool that generates test cases based
%% %on properties written in a dialect of the programming language.
%% %
%% Nevertheless, since \Prolog{} does not possess a static strong
%% type system, the interface of \plqc{} differs from the \Haskell{}
%% \QuickCheck{}.


Our tool is
lightweight and completely integrated in \Prolog{}.
%
On top of this lightweight testing tool we have built predicate
specification testing.
%
By specifying some aspects of a predicate in a proper specification
language it is possible to generate a \plqc{} property and check it.
%
This has allowed us to  use \plqc{} and its predicate specification in a number of
predicates and even libraries.


%}}} introduction


%{{{ paper outline
%% This paper is organised as follows.
%% %
%% \refSecI{}
%}}} outline


