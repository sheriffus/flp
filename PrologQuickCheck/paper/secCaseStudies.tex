% -*- mode: latex; mode: folding -*-

\section{Case Studies}
\label{sec:case-studies}

\subsection{List Processing}
We started to write small predicates and specifications along with the
tool development.
%
These small examples turned out to be interesting to show some of the
potential of \plqc{}.
%
They helped to reveal discrepancies between intended and actual
behaviour of the predicates.
%
The tool is specially useful for people that are beginning logic
programming or have their logic programming polluted by other
programming styles, such as one of the authors.


%{{{ List Reverse

\subsubsection{List Reverse}
Here we return to the first example given in \refSec{sec:properties}.
%
In general people have a conception of what is reversing the order of
elements, which is to observe the $i^th$ element of the original list as
the $(1+n-i)^th$ element of the reversed one for a list of size $n$.
%
There is also the idea of how to code such a procedure, independently of
the programming language.
%
In fact, there are quite a few ways to implement it and we played with
some implementations of the procedure.


What we intend to check about our reverse procedures is the ability to
transform an input list into its reversed counterpart.
%
This implies that the property has an input for random testing.
%
For the automatic generation of input we must decide what is the input.
%
When a procedure is polymorphic on the type of the elements of an
argument list it is usually sufficient to check its behaviour for a
single type of elements.
%
It is sometimes sufficient a finite number of values, but we can
safely overestimate the size of the type.
%
We choose to test the list predicates with lists of integer elements.
%
Therefor we use the generator for integers, \yap{int}, with the
parametric list generator, \yap{listOf(int)}.


We start with two implementations of reverse.
%
The first uses an appending predicate, described later, and the second
builds the result with an accumulator via an auxiliary predicate.
%
\begin{yapcode}
 rev_app([],[]).
 rev_app([X||XS], YS) :-
   rev_app(XS,ZS), append(ZS, [X], YS).

 rev_acc([], LR, LR).
 rev_acc([X||XS], Acc, LR) :-
   rev_acc(XS, [X||Acc], LR).

 rev_acc(L, LR) :-
   rev_acc(L, [], LR).
\end{yapcode}


We can adapt the properties in \refSec{sec:properties} to both versions.
%
We do it by identifying the property names and called predicates
appropriately.
%
For the \yap{rev_app/2} predicate we have.
\begin{yapcode}
 qcprop(double_rev_app) :-
   plqc:qcforall( listOf(int), L,
     mod:qcprop({double_rev_app_body, L})).

 qcprop({double_rev_app_body, L}) :- 
   mod:rev_app(L, LR),
   !, % enforce first solution
   mod:rev_app(LR, L2), !, L == L2.
\end{yapcode}
%
The version for \yap{rev_acc/2} is obtained by changing the affix of
identifiers from \yap{app} to \yap{acc}
%
Both properties underwent testing, passing all given tests.
%
%   ?- plqc:quickcheck(mod:qcprop(double_rev_app), [{numtests, 1000}]), plqc:quickcheck(mod:qcprop(double_rev_acc), [{numtests, 1000}]).
\begin{yapcode}
   ?- plqc:quickcheck(
          (mod:qcprop(double_rev_app))
        qcand (mod:qcprop(double_rev_acc)),
          [{numtests, 1000}]).
 OK: Passed 1000 test(s).
 yes
\end{yapcode}


To check that the order is being reversed we can randomly choose an
element (or even a random set of elements) and inspect if it is
correctly positioned in the reversed list.
%
Choosing random elements prevent us from checking the whole list.
%
\begin{yapcode}
 qcprop(rev_app_index) :-
   plqc:qcforall(
     suchThat(structure({listOf(int), int}),
       mod:valid_index),
     {L,I},
     mod:qcprop({double_rev_index_body, L, I})
   ).
 valid_index({L, I}) :-
   length(L,X), I<X.

 qcprop({double_rev_index_body, L, I}) :- 
   mod:rev_app(L, LR),
   length(L,X),
   Index is I+1, RevIndex is X-I,
   lists:nth(Index, L, Val),
   lists:nth(RevIndex, LR, Val).
\end{yapcode}
%
When performing a large number of tests this method should give good
element coverage.
%
\begin{yapcode}
   ?- plqc:quickcheck(
        mod:qcprop(rev_app_index),
        [{numtests, 1000}]).
 OK: Passed 1000 test(s).
 yes
\end{yapcode}


But since we have two implementations of the same concept we can explore
this by only performing tests on one version and stating a property
comparing their behaviours.
%
\begin{yapcode}
 qcprop(equiv_acc_app) :-
   plqc:qcforall( listOf(int), L,
     (mod:rev_acc(L,LR), mod:rev_app(L,LR))).
\end{yapcode}
The comparison succeeds if both have the same behaviour.
%
\begin{yapcode}
   ?- plqc:quickcheck(
        mod:qcprop(equiv_acc_app),
        [{numtests, 1000}]).
 OK: Passed 1000 test(s).
 yes
\end{yapcode}

%}}}

\subsubsection{Append}
The implementation of the appending predicate recurs on the first list
and the appended list parameters, leaving the second list uninspected.
%
\begin{yapcode}
 append([], YS, YS).
 append([X||XS], YS, [X||AS]) :-
   append(XS, YS, AS).
\end{yapcode}
%
We check the behaviour of the \yap{append/3} predicate
through its specification with the predicate specification language
presented in \refSec{sec:pred-spec}.
%
The most obvious way to use append is by giving it two lists and expect
the resulting appended list.
%
So the type of such a specification clause is
(\yap{listOf(int),listOf(int),variable}).
%
We can assert that, in this \plqc{} type, parameters input modes are
(\yap{ground, ground, var}) and the output modes (\yap{ground, ground,
  ground}).
%
It should also be the case that this use of the predicate behaves as a
function, expecting exactly one answer.
%
\begin{yapcode}
 mod:append
   of_type (A-(plqc:listOf(int)),
     B-(plqc:listOf(int)), C-(plqc:variable))
   where (i(g, g, v), o(g, g, g))
   has_range {1,1}.
\end{yapcode}
%
Quickchecking this specification clause bears no surprises.
%
\begin{yapcode}
   ?- plqc:quickcheck(
        mod:qcprop(spec_append),
        [{numtests, 1000}]).
 OK: Passed 1000 test(s).
 yes
\end{yapcode}


Although \yap{append/3} has an intended usage, it may be successfully
used in other situations.
%
For example, one can use it to create an open list, by giving a variable
in place of the second list, which remains uninspected.
%
The result is a list with the ground elements of the first list and the
second list variable as the tail, therefor it is neither ground nor
variable.
%
This usage also behaves as a function, since the potentially mutating
part of the input is not a target of pattern matches.
%
\begin{yapcode}
 {mod:append, 1}
   of_type (A-(plqc:listOf(int)),
     B-(plqc:variable), C-(plqc:variable))
   where (i(g, v, v), o(g, v, ngv))
   has_range {1,1}.
\end{yapcode}
%
Testing this specification clause reveals that the \emph{out} part of
the directionality is not satisfied.
%
\begin{yapcode}
   ?- plqc:quickcheck(
        mod:qcprop(spec_append_1),
        [{numtests, 1000}]).
 ..{failed_out_modes,[[o,g,v,ngv]],
                     [[],_10258,_10258]}
 !
 Failed: After 3 test(s).
 Counterexample found: [[[],_10258,_10260]] 
 yes
\end{yapcode}
%
The counterexample given shows that when the first argument is the empty
list, and the other two variables, the output modes do not comply with
the specification.
% when L1 is [], LApp is L2, i.e. var
%
Upon closer inspection it is noted that the base case of the recursion
on the first argument simply unifies the second and third parameters
when it matches an empty list.
%
There are two simple ways of solving this.
%
One is to split the specification clause between input types that only
have empty lists or non-empty lists separately.
%
The other is to add the directionality missing.
%
The correct choice in general is to split the input types, since this is
a matter between disjoint sets of terms.
%
Multiple output directionalities are mainly intended for multiple modes
of the parameters of multiple answers.
%
Given the simplicity of the example we decided to add a directionality.
%
\begin{yapcode}
   where (i(g, v, v), o(g, v, ngv)), o(g,v,v)
\end{yapcode}


%% \begin{yapcode}
%%  {mod:append, 2}
%%    of_type (A-(plqc:variable),
%%      B-(plqc:listOf(int)), C-(plqc:variable))
%%    where (i(v, g, v), o(g, g, g), o(ngv, g, g))
%%    has_range {1,1}.
%% \end{yapcode}
%%  % default 1-inf


\subsection{AVL Trees}
AVL trees are implemented in a \Yap{} module, making it interesting to
test in order to show black-box testing with \plqc{}.
%
Its interface is small, with only three predicates, to create an empty
tree, insert an element and look up an element.
%
The predicates are \yap{avl_new/1}, \yap{avl_insert/4} and
\yap{avl_lookup/3} respectively.
%
With only this interface and knowledge about the trees' shape we can
test weather the module implements AVL trees correctly.


When performing this kind of test one does not simply test individual
predicates (http://imgflip.com/i/1vrhm), we test usages of the module.
\todo{remove joke}
%
In order to do this we must be able to create sequences of interface
calls and inspect intermediate results.
%
To inspect intermediate results it is necessary to perform some
interface calls and study the result terms.

\subsubsection*{Generator}

Creating a valid sequence of interface calls is not difficult, but
requires attention to detail.
%
First, we only want to generate valid sequences.
%
This is important to save effort of checking validity and not suffer
from sparse valid values.
%
Usages the module \yap{avl.yap} have two sets of terms important to
define: key terms and value terms.
%
We decided to parametrise these sets as generators.
%
Along with generators for keys and tree values we also parametrise a
generator for failed lookups, that must be disjoint from the generator
of values.
\begin{yapcode}
 genAvl(KeyGen, ValGen, FGen, Calls, Size) :-
   Calls = [(avl:avl_new) || Cs1],
   genAvlCmds(KeyGen, ValGen, FGen,
              [], Cs1, Size).
\end{yapcode}
%
In this generator we start by creating the tree, independently of the
size parameter.
%
This implies that when size is 0 the tree is still created.
%
We append the tree creation to a sequence of calls to insert and look-up
values.


Generation of commands to insert and look-up values is passed the
information about keys and values.
%
It works by randomly choosing between insert, valid look-up and invalid
look-up.
%
After an insert command is added, the inserted key-value is saved in a
look-up list to draw future valid look-ups from.
%
Valid look-ups are not generated if the look-up list is empty.
%
When the size parameter reaches zero, we generate an empty list of
commands.
%
Otherwise a command is generated and the size is decreased at least by
one and at most to half.
%
Commands are generated without the context tree, which is managed by property.
%
\begin{yapcode}
 genAvlCmds(KeyGen, _ValGen, _FGen,
            _Lookups, [], 0) :- !.
 genAvlCmds(KeyGen, ValGen, FGen,
            Lookups, Cs, Size) :-
   genCmdHead(KeyGen, ValGen, FGen,
              Lookups, X, Size),
   call(KeyGen, Key, Size),
   (X = {i, Val},
    Cs = [{i, avl:avl_insert(Key, Val)}||CsS],
    NewLookups = [ {Key,Val} || Lookups]
   ;
    X = {fl, {FK, FV}},
    Cs = [{fl, avl:avl_lookup(FK, FV)}||CsS]
   ;
    (X = {l1, {K, V}}, Lx=l1
    ; X = {l2, {K, V}}, Lx=l2),
    Cs = [{Lx, avl:avl_lookup(K, V)}||CsS]
   ),
   MinSize is Size // 2,
   MaxSize is Size-1,
   choose(MinSize, MaxSize, NewSize, Size),
   genAvlCmds(KeyGen, ValGen, FGen,
              NewLookups, CsS, NewSize)
 .
\end{yapcode}


Choosing a single command follows a couple of restrictions.
%
If the generator for failing look-ups is missing, these commands will
not be generated.
%
If the list of look-ups is empty, valid look-ups will not be generated.
%
Valid look-ups can take two forms: checking if the key-value is in the
tree and ask for the value corresponding to some key.
%
All commands are branded by a command identifier, making it possible to
distinguish between different kinds of look-up.
%
The possible choices are bundled in a \yap{frequency} generator.
%
Relative probabilities are such that a big variety of commands occurs in
relatively small sequences.
%
\begin{yapcode}
 genCmdHead(KeyGen, ValGen, none,
           [], X, Size) :- !,
   plqc:structure({plqc:value(i), ValGen},
                  X, Size).
 genCmdHead(KeyGen, ValGen, none,
            Lookups, X, Size) :- !,
   Insert =
     plqc:structure({plqc:value(i),
                     ValGen}),
   Lookup1 =
     plqc:structure({plqc:value(l1),
                     plqc:elements(Lookups)}),
   Lookup2 =
     plqc:structure({plqc:value(l2),
                     plqc:elements(Lookups)}),
   plqc:frequency(
     [{6,Insert}, {2,Lookup1}, {2,Lookup2}],
     X, Size).
 genCmdHead(KeyGen, ValGen, FGen,
            [], X, Size) :- !,
   Insert = ... ,
   FailLookup =
     plqc:structure({plqc:value(fl),
                     {KeyGen, FGen}}),
   plqc:frequency(
     [{9,Insert}, {1, FailLookup}],
     X, Size).
 genCmdHead(KeyGen, ValGen, FGen,
            Lookups, X, Size) :-
   Insert = ... ,
   FailLookup = ... ,
   Lookup1 = ... ,
   Lookup2 = ... ,
   plqc:frequency(
     [{6,Insert}, {2,Lookup1},
       {2,Lookup2}, {1, FailLookup}],
     X, Size).
\end{yapcode}
%% \begin{yapcode}
%     plqc:structure({plqc:value(i), ValGen}),
%     plqc:structure({plqc:value(i), ValGen}),
%     plqc:structure({plqc:value(fl),
%                     {KeyGen, FGen}}),
%     plqc:structure({plqc:value(l1),
%                     plqc:elements(Lookups)}),
%     plqc:structure({plqc:value(l2),
%                     plqc:elements(Lookups)}),
%% \end{yapcode}


Together with the generators for module usages we need the generators
for keys and values.
%
Keys are integers between $0$ and $50000$, a large enough interval to
generate a fair amount of unique keys in smaller test cases.
%
Values are non-negative integers bound by the size.
%
To make a disjoint generator for we use singleton lists with elements
given by the value generator.
\begin{yapcode}
 genKey(Key, Size) :-
   plqc:choose(0, 50000, Key, Size).

 genVal(Val, Size) :-
   plqc:choose(0, Size, Val, Size).
\end{yapcode}


\subsubsection*{Property}

The avl property depends on many factors.
%
It is parametrised by the tree to check and operations to extract
information from that tree.
%
These operation consist of: current node's key; key comparison; left and
right sub-trees; empty tree test.
%
A side effect of the property is returning the height if the tree.
%
\begin{yapcode}
 qcprop({avl, (tree, T), (height, H),
      (curr_key, GetKey), (cmp_key, CmpKeys),
      (left, L), (right, R),
      (is_nil, IsNil)}) :- 
   qcif(...).
\end{yapcode}
%
The empty tree test is a callable term that checks if the tree in the
first argument is empty and unifies the second argument to the
appropriate truth value.
%
Key comparison is callable with three parameters: first key, second key
and result.
%
The result of the comparison reflects the relation between the given
keys : \yap{lt, gt, eq, lte, gte}.


A tree may be empty, in which case we just unify the correct height.
\begin{yapcode}
   qcif( (call(IsNil, T, V), V = false)
   ,(
     ...
   ),
   (V=false, H = 0) )
\end{yapcode}
%
In the case of a non-empty tree we retrieve its key and sub-trees.
%
\begin{yapcode}
   qcif( ...
   ,((call(GetKey, T, Key),
       call(L, T, LT),  call(R, T, RT))
   qcand
     ...
   qcand
     ...
   qcand
     ...
   ),
     ... )
\end{yapcode}
%
They are used in recursive checks of the property.
%
The recursive calls are for a different predicate, accumulating lists of
keys that should be greater of less then the keys of the tree.
%
After checking the sub-trees, the returned heights are compared for
balance and the current tree height computed.
%
\begin{yapcode}
   qcif( ...
   ,( ...
   qcand
     qcprop({avl, (gt, [Key]), (lt, []),
 (tree, LT), (height, LH),
 (curr_key, GetKey), (cmp_key, CmpKeys),
 (left, L), (right, R), (is_nil, IsNil)})
   qcand
     qcprop({avl, (gt, []), (lt, [Key]),
 (tree, RT), (height, RH),
 (curr_key, GetKey), (cmp_key, CmpKeys),
 (left, L),(right, R),(is_nil, IsNil)})
   qcand
     (( abs(LH-RH) =< 1, !
     ; print(height_mismatch), nl, fail),
     H is 1+ max(LH,RH))
   ),
     ... )
\end{yapcode}


The accumulating version of the property receives as extra arguments the
lists of keys in the path up to the root that are greater and less then
the current key.
%
This order criterion is what differentiates the accumulating property.
%
It is checked for the current key which is then added to the appropriate
accumulators in the recursive calls.
% (tree, T),
%       (height, H), (curr_key, GetKey),
%       (cmp_key, CmpKeys), (left, L),
%       (right, R), (is_nil, IsNil)
\begin{yapcode}
 qcprop({avl, (gt, GTS), (lt, LTS), ...}) :-
   qcif(
     ...
   ,(
     (call(GetKey, T, Key), call(L, T, LT),
      call(R, T, RT),
      (forall(member(X, LTS),
       call(CmpKeys, X, Key, lte)), !
      ; print(avl_key_not_inorder1), nl, fail),
      (forall(member(X, GTS),
       call(CmpKeys, X, Key, gt)), !
      ; print(avl_key_not_inorder2), nl, fail))
   qcand
     ...
   qcand
     ...
   qcand
     ...
   ),
     ...
   ).
\end{yapcode}

%% \subsection{red-black Trees}



\begin{yapcode}
\end{yapcode}
\begin{yapcode}
\end{yapcode}
