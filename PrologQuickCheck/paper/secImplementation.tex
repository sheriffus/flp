%% % -*- mode: latex; mode: folding -*-

\section{Implementation}
\label{sec:impl}

The \plqc{} tool is very lightweight: \plqc{} together with the predicate
specification translation it is currently less then a thousand lines
of \Prolog{} code.
  %% \todo{is this really a small program in the prolog comunity?}
  %% \todo{should one even mention the thing we are trying to
  %% sell here is small and simple?}
%
It is developed in \Yap~\Prolog{}~\cite{yap} but it is mostly comprised of
standard \Prolog{} code and should be easy to port to other
implementations.


%There is a single \plqc{} module, which has 4 interface predicates to
%run a property, depending on whether the user wants to override the defaults
%with specific options and/or have the result in a term.
%
%The main module exports the basic generator predicates and generator
%predicate combinators including, but not limited to, the ones
%presented in \refSec{sec:generators}.
%
%The module also defines the operators needed to write predicate
%specifications together with the term expansion of such specifications
%into testable properties.


One can test a property, or \emph{prologcheck} it,  by passing it as a parameter in a
call to a predicate of the \plqc{} testing interface: \yap{prologcheck/[1,2]},
%% predicate of the \plqc{} testing interface: \yap{prologcheck/[1,2]},
%% \yap{prologcheck/2}, \yap{prologcheckResult/2},
 \yap{prologcheckResult/[2,3]}.
%
The \yap{prologcheck/1} predicate tests a property and prints the results
to the standard output.
%
 %% | Tests a property and prints the results
 %% to 'stdout'.
%\begin{yapcode}
 %prologcheck(Property) :-
  % prologcheck(Property, []).
%\end{yapcode}
%
%It is a default interface to \yap{prologcheck/2}, such that the second input parameter
%is the empty list (has no user options).
%
%In general, this list is expected to contain user options to change the default
%values of key features of the testing process, covered later.
 %% | Tests a property, using test input parameters,
 %% and prints the results to 'stdout'.
%\begin{yapcode}
 %prologcheck(Property, UserOpts)  :-
  % prologcheckResult(Property, UserOpts, _Res).
%\end{yapcode}
%
%The predicate is implemented in terms of the result returning
%counterpart, simply by discarding the result.
%
%Both \yap{prologcheck} predicates have a result returning counterpart,
%result that can be used internally.
%
%The absence of user options defaults to the empty list of options, as in
%the previous interface predicates.
 %% | Tests a property, produces a test result,
 %% and prints the results to 'stdout'.
%\begin{yapcode}
% prologcheckResult(Property, Result) :-
  % prologcheckResult(Property, [], Result).
%\end{yapcode}
%The predicate \yap{prologcheckResult/3} is the main interface predicate,
%since all the others call it, either by discarding the result or by applying
%an empty list of options.
 %% | Tests a property, using test input parameters,
 %% produces a test result, and prints the
 %% results to 'stdout'.
%\begin{yapcode}
 %prologcheckResult(Prop, UserOpts, Result) :-
  % opts:parse(UserOpts, Opts),
   %state:init(Opts, IState),
   %test(Prop, Opts, IState, OState, Result).
%\end{yapcode}
%% \todo{CA: keep the code for all these predicates?}
%% \todo{CA: whole paragraph is messy...}


The process of testing a property 
involves three main implementation steps: parsing the given options to build the option data
structure; building the initial testing state from the parsed options; testing the
property w.r.t.\ the  options and initial state.
%
The option data structure is actually a structure holding information
about key aspects of the testing process.
%
It includes the printing predicate, long/short result choice, number of
tests, starting size for generated values, maximum size for generated
values, shrinking disabled, maximum number of shrinks, number
of constraint tries, and timeout limit.

%\paragraph{\plqc{} Options}
%{{{ options

%The default printing predicate is \yap{format/2}.
%
%The default can be changed with the option
%\yap{\{on_output,Print\}}, where the new printing predicate,
%\yap{Print}, is supposed to accept the same kind of parameters of
%\yap{format/2}.
%
%The first is the message structure with formatting fields and the second
%is the list of values to output in the message.
%
%This option subsumes the options \yap{quiet}, \yap{verbose} and
%\yap{\{to_stream,Stream\}}, where the new printing predicate is set to a
%predicate that does nothing, \yap{format/2} and \yap{Stream} partially
%applied to \yap{format/3}, respectively.
%% \todo{maybe simplify this sentence}


%For the result returning interface predicates one can choose between
%long and short result presentation.
%
%The short version, set by default, is just a boolean account
%(\yap{true,false}) of the tests performed.
%
%The long version attaches relevant information about a failed test
%suite.
%
%The option to set the long result is \yap{long_result}.


%One of the most important constants necessary for running a set of tests
%is knowing the number of input cases to run the property with.
%
One can also change the 100 tests default  using \yap{\{numtests,N\}} where
\yap{N} is the new number of tests given by a positive integer.
%
%The number of tests performed can drastically change the probability of
%getting a counter-example to a failing property.
%
Test generation can also be tuned to start at a different size parameter
or be given a maximum for the size parameter.
%
These alterations are achieved with the options
\yap{\{start_size,Size\}} and \yap{\{max_size,Size\}}.


Shrinking can be very useful to find good counter-examples.
%
Nevertheless it is not a straightforward process.
%% Shrinking is also a useful feature of the tool: when a counterexample to a property is found the user may want \plqc{}
%% to try to \emph{shrink} the result, making it easier to understand.
%% %
%% But this shrinking process is not exact and there may be many choices to
%% make the generated values smaller.
%
%% For this reason o
One may want to impose different limits for the maximum
number of shrinks performed, which is by default set to 500, either for getting 
a smaller result or to make the process faster.
%
This is possible with the option \yap{\{max_shrinks,N\}}.
%
%One can also choose to simply not shrink counterexamples at all with
%\yap{noshrink}.

%}}}


%% \subsection{Implementation}

%% We have two kinds of information at the disposal of \plqc{}: options and
%% state.
%% %
%% Options refer to a set of constants that do not change along the testing
%% process.% unless done explicitly by specific modifiers in the property.
%% %
%% On the other hand, state contains information that is specific to
%% the current test being performed.
%% %
%% It contains mutable information necessary to guide the testing process
%% and is initially based on the available options.
%% %
%% The state mainly keeps track of the current size parameter
%% for generating values.


%% Testing is initiated with appropriate information in a predicate
%% designed to loop the generation and application of input cases to the
%% property being tested.
%% %
%%    %% perform tests on Property
%% \begin{yapcode}
%%  test(Property, Opts,
%%       IState, OState, Result) :-
%%    %% retrieve testing attributes
%%    (...)
%%    perform(0, NumTests, N, Property, Opts,
%%            IState, OState, Result1),
%%    %% report result with printing predicate
%%    (...)
%%    %% polish testing result into long/short
%%    (...).
%% \end{yapcode}
%% %
%% The final result is reported with the printing predicate and refined
%% into the return long/short form.


%% \paragraph{Algorithm}

%% The main test loop, \yap{perform/8}, operates by making a complete copy
%% of the given property with fresh variables.
%% %
%% The copy is ran and the state information is recovered to continue the
%% process.
%% %
%% The result is inspected and treated accordingly.
%% %
%% \begin{yapcode}
%%  perform(Passed, ToPass, TriesLeft, Property,
%%          Opts, IState, OState, Result) :-
%%    duplicate_term(Property, Test),
%%    run(Test, Opts, IState, State1, Res),
%%    (
%%     % passing result; count test
%%     % proceed with updated loop information
%%     % grow size; +1 passed; -1 tries left
%%    ;
%%     % failing result; count test
%%     % build result and out state
%%    ;
%%     % error; deal with it
%%    ).
%% \end{yapcode}
%% %
%% %% While a property is being processed, predicates from different modules
%% %% are used.
%% %
%% Other clauses of the main loop deal with the loop boundaries: number of
%% tries and number of successful tests.


%% Running a property once requires information from option constants, a state to
%% keep track of the environment and a context for saving quantification
%% variable bindings.
%% %
%% On the absence of some of these elements, defaults are used.
%% %
%% \begin{yapcode}
%%  run(Test, Opts, ISt, OSt, Result) :-
%%    ctx:default(Ctx),
%%    run(Test, Opts, Ctx, ISt, OSt, Result).
%% \end{yapcode}


%% To run a property one descends its structure.
%% %
%% Properties in a conjunction are examined \emph{in order}.
%% %
%% All predicate calls in a property are used with the
%% corresponding module.
%% %
%% An explicit reference to a module in the property is taken into the
%% property's context.
%% %
%% In the presence of a \plqc{} quantification the value that is given by
%% the generator is bound to the quantified variable, propagated by
%% unification to the enclosed property.
%% %
%% \begin{yapcode}
%%  run(for_all(Gen, Var, Test, Size),
%%      Opts, Ctx, IState, OState, Result) :- 
%%    !, bind_forall(Gen, Ctx, Var, Size),
%%    ctx:bind(Ctx, Var, Ctx1),
%%    run(Test, Opts, Ctx1,
%%        IState, OState, Result).
%% \end{yapcode}
%% %
%% The binding is saved in the context.
%% %
%% Base properties are called and its outcome accounted for.
%% %
%% %% \todo{this paragraph just sucks...}


%% \subsection{Predicate Specification Term Expansion}

%% The predicate specification language defined in \plqc{} is
%% translated into a \plqc{} property by the term expansion mechanism.
%% %
%% At compilation, this mechanism transforms a specification clause into
%% code that implements a testable property.


%% The specification clause to be transformed is composed by the
%% identification element (\yap{PredId}) and corresponding
%% information (\yap{T}).
%% %
%% \begin{yapcode}
%%  user:term_expansion(
%%        PredId of_type T,
%%        (prop(PropName) :- PLQCProp) ) :-
%%    (...).
%% \end{yapcode}
%% %
%% From the identification element we extract the predicate that is being
%% specified and derive the name of the property.
%% %
%% \begin{yapcode}
%%    pred_spec_name(PredId, Pred, PropName),
%%    spec_expand(Pred, T, PLQCProp)
%% \end{yapcode}
%% %
%% All the actual specification elements reside in \yap{T} and that,
%% together with the name of the predicate being specified, is expanded
%% into the property to be tested.


%% The predicate identification expects either the atom corresponding to
%% the predicate name or a pair where the first component is the atom name
%% and the second is an atomic symbol.
%% %
%% The first case can only be used by one specification clause and the
%% property identification is merely the name of the predicate.
%% %
%% Care is advised when choosing this identification form since it will not
%% differentiate predicates with different arities nor multiple clauses of
%% the same predicate.
%% %
%% When a pair is given, the second element is taken as a suffix to the
%% name separated by an underscore character.
%% %
%% An exception is made when the suffix itself starts with the underscore
%% symbol in which case it is just appended to the name as an atom.


%% %% The type of input to be generated is the only mandatory field.
%% %% %
%% %% The priority of its operator relative to the other operators in a
%% %% specification accomodates this functionality.
%% %% %
%% %% In fact, operator priorities are stated in a way that intuitively suits the
%% %% translation order, even if they could arguably be swapped in some cases.
%% %% %
%% %% \begin{yapcode}
%% %%  of_type > (such_that < where < has_range
%% %%             < limit < pre_cond < post_cond)
%% %% \end{yapcode}
%% %% %% \begin{yapcode}
%% %% %%  :- op(910, xfx, of_type).
%% %% %%  :- op(700, xfx, such_that).
%% %% %%  :- op(750, xfx, where).
%% %% %%  :- op(800, xfx, has_range).
%% %% %%  :- op(850, xfx, limit).
%% %% %%  :- op(890, xfx, pre_cond).
%% %% %%  :- op(900, xfx, post_cond).
%% %% %% \end{yapcode}
%% %% %
%% %% Even though the relative priorities of the specification operators is
%% %% important, their absolute values are not, as they are not supposed to
%% %% be used together with other
%% %% \Prolog{} operators.


%% The specification expansion is aided by an accumulator of property
%% modifiers which are examined when building the property for relations
%% between modifiers.
%% %
%% Predicate directionality and range as well as the limit of the search
%% space contribute to shape the main property, regarding the predicate
%% call.
%% %
%% Next, re- and post-conditions are attached to the appropriate place: the
%% beginning of the property and after every calculated answer,
%% respectively.


%% The specification expansion terminates with the actual typing of the
%% specification clause and the collection of any other specification fields
%% characterised in the accumulated modifiers.
%% %
%% \begin{yapcode}
%%  spec_expand(Modifs, Pred, Types, Prop) :-
%% \end{yapcode}
%% %
%% The types are pre-processed into the type structure and input parameter labels.
%% %
%% The type structure then originates the generator of input parameters.
%% %
%% A goal centred in the predicate and respecting the collected modifiers
%% is wrapped in a quantification abstracting the input parameters.
%% %
%% The resulting property is ready to be tested.
%% %
%% \begin{yapcode}
%%    pp_typing(Types, TS, Args),
%%    modify_gen(Modifs, structure(TS), ArgGen),
%%    spec_prop(Modifs, Pred, Args, InnerProp),
%%    Prop = for_all(ArgGen, Args, InnerProp).
%% \end{yapcode}



%% Type pre-processing builds the list of type structures from the sequence
%% given in the specification clause types.
%% %
%% This includes all necessary generators and possible parameter term
%% patterns.
%% %% , such as the list pattern.
%% %
%% In parallel it is also built the list of input parameters that parametrise the
%% translated property.
%% %
%% %% The input parameters are variables into which each generated input parameter will be
%% %% bound to, taking into account explicit variable names provided in the
%% %% type specification.



%% The list containing the input parameter patterns and generators is assembled
%% as a structure generator.
%% %
%% In the presence of a parameter relation, collected in the modifiers, the
%% single generator is conditioned to values that satisfy the given
%% relation with the \yap{suchThat/2} generator combinator.
%% %
%% The final property universal quantification binds values from the
%% generator with the input parameters, parametrising the test goal.



%% The test goal effects all single test cases generated.
%% %
%% Its base is the main call, a call to the specified predicate in order to
%% assert the correction of value's types.
%% %
%% Based on the collected modifiers a property can be attached both before and
%% after the main call as the specified pre- and post-conditions.
%% %
%% The post-condition is checked for all the answers retrieved from the
%% main call.
%% %
%% The main call is also improved by checks on the parameters before and
%% after execution for the directionality of the input and all the answers.
%% %
%% The range of a predicate is checked within a limit number of answers.
%% %
%% This is done within a loop predicate wrapping the main call and the
%% inspection of the result for directionality and post-conditions.


%% The loop is a bounded version of the \yap{forall/3} built-in
%% meta-predicate.
%% %
%% It works by storing relevant information with stateful
%% %% (non-backtrackable)
%%  procedures before enforcing backtracking for
%% alternatives.
%% %
%% The original input parameters are stored for inspection in case an error
%% occurs.
%% %% %
%% %% At each iteration the current number of retrieved answers is checked
%% %% against the bounds.
%% %
%% In case none of the upper bounds on the number of answers are passed, the result
%% parameters are checked against result properties: directionality and
%% post-condition.
%%      %% answer counter (ac) exceeds upper bound
%% \begin{yapcode}
%%  bound_call(Lower, Upper, Limit,
%%             (Call, OutProp), Args) :-
%%    %% setting non-backtrackable (nb) details
%%    (
%%     %% make call and update nb values
%%     (
%%      %% answer counter (ac) exceeds maximum
%%      %% report and finish
%%     ;
%%      %% ac exceeds defined limit
%%      %% report and finish
%%     ;
%%      %% otherwise continue
%%      %% with after-properties and fail
%%     )
%%    ;
%%     %% final ac does not meet lower bound
%%     %% report and finish
%%    ;
%%     %% loop succeeds and result is built
%%    ).
%% \end{yapcode}
%% %% \begin{yapcode}
%% %% \end{yapcode}

%% %% \begin{yapcode}
%% %% \end{yapcode}
