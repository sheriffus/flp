% -*- mode: latex; mode: folding -*-


\section{Motivating Examples}
%% \section{Case Studies}
\label{sec:motiv-ex}

%{{{ append

\subsection{Append}
%% \paragraph{\bf Append}
Consider the well-known concatenation predicate.
%
\begin{yapcode}
 app([], YS, YS).
 app([X||XS], YS, [X||AS]) :- app(XS, YS, AS).
\end{yapcode}
%
We specify the predicate behaviour through the predicate
specification language presented in \refSec{sec:pred-spec}.
%
The properties and predicates to be tested are in module \yap{m}.
%



\yap{app(A,B,C)} is used in a functional way in many programs,
i.e., by giving it two lists as input and getting their concatenation as
output.
%
The directionality is determined by the modes of each
parameter: \emph{ground, ground, variable} to \emph{ground, ground, ground}.
%
The range of answers for a predicate with a (total) functional
behaviour is exactly one.
%
This behaviour is specified in \plqc{} as:
\begin{yapcode}
 app of_type (A-(listOf(int)), B-(listOf(int)), C-(variable))
   where (i(g, g, v), o(g, g, g))  has_range {1,1}.
\end{yapcode}
%
The property originated by this specification clause passes the tests
generated by the tool.
%
\begin{yapcode}
   ?- prologcheck(m:prop(spec_app)).
 OK: Passed 100 test(s).
\end{yapcode}




\yap{app/3} may be used in other situations.
%
One can use it to create an open list bound to the third
parameter by calling it with a variable in the second input parameter,
which remains uninspected.
%
The result is a list with the ground elements of the list in the first
parameter and the variable in the second parameter as the tail,
therefore it is neither ground nor variable.
%
This usage also behaves as a function.
%
We state this as specification clause \yap{1} of predicate \yap{app}.
%
\begin{yapcode}
 {app, 1} of_type (A-(listOf(int)), B-(variable), C-(variable))
   where (i(g, v, v), o(g, v, ngv))  has_range {1,1}.
\end{yapcode}
%
Testing 
reveals that the \emph{out} part of
the directionality is not satisfied.
\begin{yapcode}
  ?- prologcheck(m:prop(spec_app_1), [noshrink]).
 {failed_out_modes,[[o,g,v,ngv]], [[],_10258,_10258]}
 Failed: After 3 test(s).
 Counterexample found: [[[],_10258,_10260]] 
\end{yapcode}
%
The counterexample shows that the output modes do not respect the
specification when the first input parameter is the empty
list.
%
One way to solve this issue is to add the missing directionality
\yap{(i(g, v, v), o(g, v, ngv)), o(g,v,v)}.
%
Although, the correct choice in general is to split the input types,
since this is a matter between disjoint sets of terms.
%
Multiple output directionalities are mainly intended for multiple modes
of multiple answers.
%
\begin{yapcode}
 {app, 1a} of_type (A-(listOf1(int)), B-(variable), C-(variable))
   where (i(g, v, v), o(g, v, ngv))  has_range {1,1}.

 {app, 1b} of_type (A-(value([])), B-(variable), C-(variable))
   where (i(g, v, v), o(g, v, v))  has_range {1,1}.
\end{yapcode}


%}}} append


%{{{ List Reverse

\subsection{List Reverse}

Let us explore an example of list reversing predicates.
%
The reversing procedure relates two lists and is
polymorphic in the type of the list's elements.
%
It is usually sufficient to check the behaviour for a
single type of elements.
%
Moreover, sometimes even a type with a finite number of values suffice,
but we can safely overestimate the size of the
type~\cite{Bernardy-testing-poly-prop}.
%
Therefore, we use the generator for integers, \yap{int}, as the elements
of the parametric list generator, \yap{listOf(int)}.



\begin{yapcode}
 rev([],[]).
 rev([X||XS], YS) :- rev(XS,ZS), append(ZS, [X], YS).
\end{yapcode}
%
We express the symmetry of the reversing relation in terms of
its intended use: given a ground list in one input parameter retrieve a
result in the other.
%
\begin{yapcode}
 prop(d_rev) :- for_all(listOf(int), XS, (rev(XS, RX), rev(RX, XS)))
\end{yapcode}
%
\emph{Prologchecking} the property bears no surprises.
%
\begin{yapcode}
   ?- prologcheck(m:prop(d_rev)).
 OK: Passed 100 test(s).
\end{yapcode}


We could have mis-typed the property, making it impossible to be
satisfied:
%
\begin{yapcode}
 prop(wrong_dr) :-
   for_all(listOf(int), XS, (rev(XS,RX), rev(RX,RX))).
\end{yapcode}
%
We mistakenly make the second call to \yap{rev/2} with \yap{RX} as
the second parameter.
%
\begin{yapcode}
   ?- prologcheck(m:prop(wrong_dr)).
 Failed: After 11 test(s).
 Shrinking (6 time(s))
 Counterexample found: [[0,6]] 
\end{yapcode}
A counterexample is found and shrunk to the presented counter-example
\yap{[0,6]}.


To check that the order is being reversed we can randomly choose an
element (or a set of elements) and inspect its position in the
parameters.
%
Choosing random elements prevent us from checking the whole list.
%
\begin{yapcode}
 prop(rev_i) :- plqc:for_all(
     suchThat(structure({listOf(int), int}), m:valid_index),
     {L,I}, m:prop({double_rev_i_body, L, I}) ).
 valid_index({L, I}) :- length(L,X), I<X.

 prop({double_rev_i_body, L, I}) :- 
   m:rev(L, LR), length(L,X), Index is I+1, RevIndex is X-I,
   lists:nth(Index, L, Val), lists:nth(RevIndex, LR, Val).
\end{yapcode}
%
When performing a large number of tests this method should randomly
choose enough indexes to give good element coverage.
%
\begin{yapcode}
   ?- prologcheck(m:prop(rev_i)).
 OK: Passed 100 test(s).
\end{yapcode}


We have another implementation of reverse, using an accumulator
 instead
of concatenation.
%
The previous properties can be adapted to this implementation with the
same results.
%
\begin{yapcode}
 rev_acc([], LR, LR).
 rev_acc([X||XS], Acc, LR) :- rev_acc(XS, [X||Acc], LR).

 rev_acc(L, LR) :- rev_acc(L, [], LR).
\end{yapcode}



Since we have two implementations of the same concept we can explore
this by stating and testing a property comparing their behaviours.
%
\begin{yapcode}
 prop(eqv_acc_app) :-
   for_all(listOf(int), L, (rev_acc(L,LR),rev(L,LR))).
\end{yapcode}
The comparison succeeds if both have the same behaviour.
%
\begin{yapcode}
   ?- prologcheck(m:prop(eqv_acc_app)).
 OK: Passed 100 test(s).
\end{yapcode}


%}}}

%{{{ avl

%% \subsection{AVL Trees}

%% We have described AVL properties and performed black-box testing of an
%% implementation of AVL trees in a \Yap{} module, \yap{avl.yap}, with
%% \plqc{}\footnote{All the details can be found in the tool's website.}.
%% %%
%% Due to space restrictions we only present a general description of the
%% process and its results. 


%% The module interface is small, with predicates to create an empty
%% tree, insert an element and look up an element, respectively
%% \yap{avl_new/1}, \yap{avl_insert/4} and \yap{avl_lookup/3}.
%% %
%% When performing this kind of test one does not simply test individual
%% predicates but rather usages of the module.
%% %
%% To do this we must be able to create sequences of interface
%% calls and inspect intermediate results for compliance with AVL
%% invariants.
%% %
%% Knowledge about the shape of input/output terms can be gathered manually
%% if it is not previously known.


%% \paragraph{\bf Generator}

%% Creating a valid sequence of interface calls is not difficult, but
%% requires attention to detail.
%% %
%% First, we only want to generate valid sequences to save effort of
%% checking validity and not suffer from sparse valid values.
%% %
%% Using the \yap{avl} module implies the existence of two sets of important
%% terms: key terms, and value terms, which we represent as generators.
%% %
%% In order to test the correct failure of wrong look-ups, a set of values
%% for failed look-ups disjoint from the regular values is also
%% implemented.


%% The generator starts by creating the tree, independently of the
%% size parameter, using \yap{avl_new/1}.
%% %
%% This implies that when size is 0 an empty AVL-tree is still created.
%% %
%% Thus, we always append the tree creation to a sequence of calls to
%% insert and look-up values.
%% %
%% Each element of the sequence is obtained by randomly choosing between
%% insert and look-ups.


%% When an insert command is added to the sequence, the value to be
%% inserted is kept so that it can be used in later look-ups.
%% %
%% Look-ups are divided between valid look-up and invalid look-up.
%% %
%% Valid look-ups are only generated after the corresponding insert and
%% invalid look-ups are based in a set of values that is never inserted.
%% %
%% Valid look-ups can be further distinguished between looking up a
%% key-value pair and looking up a key and retrieving its value.
%% %
%% These elements are  branded by a command identifier to recognise their
%% correct behaviour during testing.
%% %
%% The relative probabilities are such that we get a big variety of commands within
%% relatively small sequences.



%}}}

%% \paragraph{\bf Property}

%{{{ generic property

%% The definition of the AVL property depends on several factors.
%% %
%% It is necessary to have operations to extract information from trees,
%% such as current node's key, key comparison, left and
%% right sub-trees and empty tree test.


%% A tree may be empty, in which case it is an AVL tree of height 0.
%% %
%% In the case of a non-empty tree we retrieve its key and sub-trees.
%% %
%% They are used in recursive checks of the property.
%% %
%% The recursive calls accumulate lists of keys that should be greater and
%% less then the keys in the sub-trees.
%% %
%% If the sub-trees are individually compliant with the property, we
%% proceed with the last check, comparing the returned heights for
%% balance and computing the current tree height.
%% %
%% This is how the property is outlined in \plqc{}:


%% \begin{yapcode}
%% prop({avl, T, Gs, Ls, H}) :- if (not isNil(T)) then
%%  ((getKey(T, K), left(T, L),  right(T, R),
%%       ((forall(member(X, Ls), cmpKeys(X, K, gt))) -> error1),
%%       ((forall(member(X, Gs), cmpKeys(X, K, lte))) -> error2))
%%    and prop({avl, L, [Key||Gt], Lt, Hl})
%%    and prop({avl, R, Gt, [Key||Lt], Hr})
%%    and (( abs(Hl-Hr)>1 -> error3), H is 1+max(Hl,Hr)))
%%  else (H = 0).
%% \end{yapcode}
%% %
%% We complete the property by inserting it into a loop that consumes the
%% operations in the quantified module uses.



%% \refTabI{tab:avl-tests} summarises some relevant results of our tool
%% applied to the AVL library.
%% %
%% Each line corresponds to a different module version: line 1 to the
%% original version; line 2 to a bug in the re-balancing strategy inserted
%% by the tester; line 3 to a different bug also in the re-balancing
%% strategy inserted by someone that was not involved with the tests.
%% %
%% The column \emph{Tests} is the number of tests needed to achieve a
%% particular counter-example.
%% %
%% For the purpose of readability we will represent only the key and value
%% input parameters of the AVL operations.
%% %
%% Thus consider \yap{i(N,V)} as insert an
%% element with key \yap{N} and value  \yap{V}, and \yap{l(N,V)} as look up
%% the pair \yap{(N,V)} in the tree.


%% Note that the counter-example found in the original version corresponds
%% to an unspecified behaviour in the case of two insertions with the same key.
%% %
%% After several runs of the tool (10 for the first bug and 20 for the
%% second) we managed to find a pattern on the counter-examples which led
%% to the identification of the pathological behaviour caused by the bugs.


%% \begin{table}
%%   \centering
%%   \begin{tabular}{||c||c||l||}
%%     \hline
%%     Version    &  Tests   &  Counter-example
%%     \\ \hline
%%     Original   &  732     &  \yap{i(1,a), i(1,b), l(1,b)}
%%     \\ \hline
%%     Error 1    &  51      &  \yap{i(3,a), i(1,b), i(2,c)}
%%     \\ \hline
%%     Error 2    &  213     &  \yap{i(5,a), i(2,b), i(3,c), i(4,d), i(1,e)}
%%     \\ \hline
%%   \end{tabular}
%%   \caption{{\tt avl} testing summary.}
%%   \label{tab:avl-tests}
%% \end{table}



%}}}
