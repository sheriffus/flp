% -*- mode: latex; mode: folding -*-

\section{Introduction}
\label{sec:intro}
%{{{ introduction text

%Narrative: 
%  What (is the subject),
%  why  (are we exploring it) and 
%  how  (are we doing it)

% the Introduction intro, a bit of 'what'
Maintenance is the biggest slice of the development cycle of software
systems.
\todo{find a good source to cite}
%
Early detection and correction of bugs is then crucial to minimise
maintenance efforts and therefore its associated costs.
%
To detect or prevent such shortcomings testing has been widely used with
growing importance in industry.
 \todo{I do not like the word technique here; maybe change whole sentence}
 \todo{cite some quviq industry related testing job}
%
Regardless of the formal and constructive nature of logic programming,
rare cases and typing mistakes makes it necessary to regularly test
during logic program development.

%  What (is the subject)
Testing a software component or components consists of executing it for
a pre-selected set of inputs (test suite) and inspect if the outputs
respect the expected results.
%
%% Software testing can be classified by the granularity of test focus, the
%% tester point of view or approach.
%% %
%% Tests can focus on the behaviour of single components (unit testing), the
%% correct interaction of components (integration testing) or that the
%% whole system complies to its specification (system testing).
%% %
%% A library user has its access limited to the given interface in order to
%% test its behaviour whereas the developer may want to check invariants
%% and the integrity of internal data-structures.
%
The way individual test cases are chosen to be part of the test suite
can be either manual, where the test developer designs test cases one by
one, or with any degree of automation, resorting to tools for the
effect.
%
Such tools reduce time needed for testing software components and make
it easier to test developing programs.
%
In this paper we describe \plqc{} (\Prolog\QuickCheck), a \Prolog{}
version of the property based testing framework \QuickCheck, a tool for
testing \Prolog{} programs.
\todo{cite quickcheck}
%
We also present a language for the specification of \Prolog{} predicates
together with a translation procedure for generating \plqc{} properties
based on the specification.


%  why  (are we exploring it) and 
Programming in logic languages such as \Prolog{} can largely benefit
from automatic testing.
%
Due to its untyped nature the developer may be oblivious to important
corner cases or odd behaviours.
%
The backtracking execution model can also interfere in less obvious
ways, making the actual behaviour elude the programmer.
%
Being able to automatically test a property about a predicate or set of
predicates is a clear advantage during software development.
%
\Prolog{}'s ties to logic reduces the gap between the program and the
specification of properties to be tested.
%
Therefore, a property based approach to testing is intuitive for the
logic programmer.  


%  how  (are we doing it)
Tests are automatically run from formal specifications of general
properties and feedback is given to the tool user about their
evaluation.
%
Properties are stated through a domain-specific language wrapping a
\Prolog{} goal, which \plqc{} checks for a number of inputs.
%
Singleton properties are, even though nor enforced, pure predicate calls
whose successful execution determines that the property holds for the
given input.


The automatic generation of input for a particular test case of a
property is random w.r.t. a size parameter for the generated value.
%
The user has the freedom to decide how to compose the test data
generators to best fit the tests' purpose.
%
From simple generators and using the provided predicate generator
combinators it is possible to obtain generators for more complex
domains, provide suitable value distributions for specific predicates or
predicate uses and to ensure the relation between the arguments applied
to the predicates being tested is valid.


%  something different
Since \plqc{} is a tool to test \Prolog{} programs we took advantage of
the nature of the language and loosened the requirements for property
specification.
%
Traditional interfaces rely on built-in mechanisms, such as equality or
a boolean type, to determine primitive properties.
%
Even if they are composed of software units of other types they still
need to be able to evaluate to a truth value in order to assess a
property validity.
%
With \Prolog{} there are no such restrictions: any goal may be a property.
%
Instead of expecting a reduced set of syntactic elements to describe
properties, in \plqc{}, a property is a goal and it is satisfied when
the execution of the goal, given all necessary input, succeeds.
%
Input to such goals is given based on \plqc{} value abstraction,
quantification over a domain represented by a term generator.
%
Testing will consist on repetitively calling the goal for multiple
potential inputs.


%  overview
Following the original \QuickCheck{} implementation, our main tool is
lightweight and completely integrated in \Prolog{}.
%
On top of this lightweight testing tool we have built predicate
specification testing.
%
By specifying some aspects of a predicate in a proper specification
language it is possible to generate a \plqc{} property and check it.
%
We have used \plqc{} and its predicate specification in a number of
predicates and even libraries.

The \plqc{} tool is inspired by \QuickCheck{} and retains its main
ideas.
%
It is an automatic software testing tool that generates test cases based
on properties written in a dialect of the programming language.
%
Nevertheless, since \Prolog{} does not possess a built-in static strong
type system, the interface of \plqc{} differs from the \Haskell{}
\QuickCheck{} one.


%}}} introduction


%{{{ paper outline
This paper is organised as follows.
%
%% \refSecI{}
%}}} outline


