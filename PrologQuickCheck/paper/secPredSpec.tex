% -*- mode: latex; mode: folding -*-

\section{Specification Language}
\label{sec:pred-spec}

In this section we describe our predicate specification language.
%
Throughout, we follow some of the principles presented
by Deville~\cite{Deville1990logprog}.
%
There are several ways to state a predicate's specification, %% we do not
%% argue that our specification process is superior to other approaches.
%% %
%% We do
but we
 believe that this approach fits naturally our needs, namely as a
form to express testable predicate features. %% we thought to be of importance.


The general specification form of a predicate \yap{p/n} consists, at its
core, of a set of uniquely identified specification clauses
 %% (with \emph{clause Id})
 about \emph{input types} or the shape of the parameters when evoking the predicate.
%
%% \begin{code}
%% predicate specification clause
%%   p Id
%% parameter input types
%%   T1, ..., Tn
%% \end{code}
%
Various aspects of the predicate for the particular input type in
question can be added to a specification clause.
%
If there is
a \emph{parameter relation} or
 a relation that input parameters must fulfil one can implement it
as a predicate %% , say \yap{irel/1},
which checks if such a relation is
valid for the list of input parameters given.
%% \todo{era para cortar? 'which checks if such a relation is
%% valid for the list of input parameters given as parameter'}
%
The \emph{modes} of each parameter can be given for the input parameters and also
for  output answers.
%
The language also allows stating the number of
answers of a predicate,
or its \emph{range}.
%
Last, the user may state invariant properties that should hold both
before and after the predicate is executed as \emph{pre-} and \emph{post-conditions}.
%
%% \begin{code}
%% parameter relation
%%   irel([A1,...,An])
%% mode
%%   i(Mi1,...,Min), [o(Mo1,...,Mon)]
%% range
%%   {Min,Max}
%% pre/post conditions
%%   Goal
%% \end{code}
Next, we discuss the main properties that we allow in our framework.

%% \subsection{Types}
\paragraph{\bf Types}

Types are the mandatory part of the specification.
%
They are required to guarantee that the specification may be
automatically tested.
%
We define a type as follows: 
%
\begin{definition}
\label{def:type}
A {\em type} is a non-empty set of terms.\\
A term $t$ belongs to a type $\tau$ ($t \in \tau$) if it belongs to the set of
terms that define the type.
\end{definition}


Types are not defined as a set of \emph{ground} terms but rather by
a set of terms.
%
%% These are the types used in our predicate specifications.
%
Note that types defined in this manner depict perfectly possible forms of
predicate input.
%
This approach for types %% already
encloses, by definition, the type
precondition, where the input must be compatible with the specified types.


The types mentioned in a predicate specification clause correspond to \plqc{}
generators used to automatically create %% individual
test cases.
%
This means that the type in a specification clause is partial in the
sense that it only specifies that the predicate should succeed when given
elements of such types as parameters.
%
It states nothing about parameters of other types.
%
Other input types can be covered by other specification clauses with
different generators.
%
The %% effect of a procedure execution
behaviour of a procedure
for types not covered by any of the
specification clauses is considered undefined/unspecified.


We can now easily specify input types for program predicates like \yap{app/3}.
%
We identify the specification clauses as \yap{\{app,K\}}, specification
clause \yap{K} of predicate \yap{app}, and declare the \plqc{} types.
%
The specifications can be tested and the predicate checked to succeed
for the corresponding input types.
%
\begin{yapcode}
 {app,1} of_type (listOf(int), value(v), variable)
 {app,2} of_type (listOf(int), variable, variable)
 {app,3} of_type (listOf(int), listOf(int), variable)
\end{yapcode}


%% \subsection{Domain}
\paragraph{\bf Domain}

Correct typing of parameters is crucial but may be insufficient to
express the allowed input.
%
Sometimes the input parameters must obey a relation extending type information,
based on the actual values of the parameters.
%
The domain of a predicate is the set of parameters accepted by a
predicate~\cite{Deville1990logprog}.
%
The domain precondition is a restriction over the set of parameters of a
predicate.
%
Suppose that \yap{minimum(A,B,C)} is a predicate that succeeds when
\yap{C} is the minimum of \yap{A} and \yap{B}.
%
The predicate has the type \yap{(int, int, int)} and the domain is the
restriction \yap{(C==A; C==B),(C<=A, C<=B)}.
%% Suppose that \yap{even/1} is a predicate that succeeds when the input parameter
%% is an even number.
%% %
%% The predicate has the type \yap{int} and the domain is the restriction \yap{N rem 2 == 0}.
%% \todo{colocar exemplo concreto? \yap{even(N) :- N rem 2 == 0.}}


\begin{definition}
\label{def:domain}
A {\em domain} of a procedure p/n is a set of term
n-tuples such that\\
\qquad $\langle t_1,...,t_n \rangle \in (\tau_1 \times ... \times
\tau_n)$\\
\qquad $\langle t_1,...,t_n \rangle$ satisfies the input parameter relation
\end{definition}


This definition of a domain, similarly to what happens with types, is
different from the usual notion of domain.
%
It focus on the shape of the input to a predicate and not the accepted
answer set.
%
The \plqc{} domain of a predicate is then any set of terms produced by
the generator that fulfils the domain precondition.
%
%% In the absence of a domain precondition relating parameters the domain
%% is the set of terms generated.
%
A specification clause can thus be engineered to represent a subset of
a more general type.
%
An example could be that we want to test \yap{app} with at least one
non-empty list input.
%
This can be used, for example, to guarantee that the variable given in
the third input parameter will be instantiated with a non-empty list.
\begin{yapcode}
 non_empty( [[_||_],_,_] ).
 non_empty( [_,[_||_],_] ).
 {app,3b} of_type (listOf(int), listOf(int), variable)
    such_that m:non_empty.
\end{yapcode}



%% \subsection{Directionality}
\paragraph{\bf Directionality}

The directionality of a predicate describes its possible uses by
specifying the possible forms of the parameters before and after
execution.
%
We follow Deville~\cite{Deville1990logprog} where the main modes for a
parameter are ground, variable and neither ground
nor variable.
%
Conjunction of modes is also possible and all combinations are achieved
by the notation for ground (\emph{g}) and variable (\emph{v}) as well as
the negation (\emph{n?}).
%
This results in the main modes and their pairwise combinations: \emph{g},
\emph{v}, \emph{gv},  \emph{ng}, \emph{nv}, \emph{ngv}.
%
A parameter that can be used in any form is denoted by the mode
identifier \emph{any}.


\begin{definition}
\label{def:modes}
The \emph{modes} or \emph{forms} a term may present are denoted by\\
 $Modes = {g, v, gv, ng, nv, ngv, any}$
\end{definition}


There are two components to a directionality: input and output.
%
They must hold for a predicate's parameters before and after execution,
respectively.
%
This means a full directionality denotes a pre- and a post-condition to
the execution of the specified predicate.
%
In \plqc{} these properties are checked for each test case when
specified before and after calling the predicate.


Input directionality acts as a sanity check for the elements of the
domain, meaning that the generators must be constructed to conform to the
specified input modes.
%
Each specification clause is allowed one input directionality.
%
If the user wishes to specify more than one input form the clause should
be divided into the number of input forms and its generators adapted
accordingly.
%
This results in bigger predicate specifications with possibly
duplicated code, but is a very simple way to express what happens to the
parameters in finer detail.


Each input may have more than one answer and therefore more than one
output form.
%
For this reason we adopted a schema where an input directionality is
paired with a list of output forms.


\begin{definition}
\label{def:directionality}
A \emph{directionality} of a specification clause of a predicate
p/n is a sequence of \emph{predicate modes}, with one input mode
followed by one or more output modes.
\\
A predicate mode of p, or just mode of p, is denoted as

\;\;  -- $i(m_1, ..., m_n)$

\;\;  -- $o(M_1, ..., M_n)$
\\
%% \quad
%% \begin{itemize}
%%   \item $i(m_1, ..., m_n)$
%%   \item $o(M_1, ..., M_n)$
%% \end{itemize}
where $m_i,M_i \in Modes$ and $i, o$ respect to input and output modes
respectively.
\end{definition}


The specification of input and output modes is important to state
predicate behaviours that may be oblivious to a library user.
%
From using the predicate \yap{app/3} with a list and two variables, for
example, two distinct directionalities may arise.
%
This is due to the fact that an empty list in the first input parameter does
not contribute to instantiate any part of the third parameter.
%
\begin{yapcode}
 {app, 4} of_type (listOf(int), variable, variable)
    where (i(g, v, v), o(g, v, ngv), o(g, v, v)).
\end{yapcode}

%% \todo{talk a little about inconsistent directionalities (v<ngv<g),
%%   which are only caught during testing...}
%% \todo{maybe also about minimality and how we just don't care, we test}

%% \subsection{Multiplicity}
\paragraph{\bf Multiplicity}
The number of answers a predicate call has can also be valuable
information.
%
Knowing a predicate has a finite search space is a termination
guarantee for predicates using it.
%
Conventionally, multiplicity information, or \emph{range}, is given for
each directionality~\cite{somogyi1995mercury}.
%
In \plqc{} we do not require that directionality is given, in which
case no tests are performed regarding parameter form and the \emph{any}
mode is assumed for all parameters.
%
The multiplicity is tied to the domain of each specification clause
where defined.


The range of answers is given with two bounds: \emph{Min} and
\emph{Max}.
%
These values are the lower and upper bounds to the number of answers.
%
The lower bound should not exceed the upper bound and they both take
non-negative integer values up to infinity (denoted by the atom
\yap{inf}).
%
When no explicit multiplicity is given the default we %% choose to 
follow is
$\langle 1, inf \rangle $.
%
When testing a specification clause, the default minimal expected
behaviour is that the domain is successfully accepted by the predicate.
%
Therefore we try to mirror this when there are other features
specified but no multiplicity, expecting at least one solution.
%
It is necessary to impose a limit when the upper bound is infinity or an
excessively large number.
%
One can state the maximum number of answers necessary to assume that the
answer range is sufficiently close to the upper bound with a positive
integer.
%
We can complement the previous specification clause with a statement
about the predicate behaviour regarding the number of answers.
%
In this case we have a total function behaviour, always yielding one and
only one answer.
%
\begin{yapcode}
 {app, 4b} of_type (listOf(int), variable, variable)
    where (i(g, v, v), o(g, v, ngv), o(g, v, v))
    has_range {1,1}.
 {app, 4c} of_type (variable, listOf(int), variable)
    where (i(v, g, v), o(g, g, g), o(ngv, g, ngv))
    has_range {1,inf} limit 50.
\end{yapcode}

%% \subsection{Pre- and Post-conditions}
\paragraph{\bf Pre and Post-conditions}

Along with all the other features of a predicate we can have a
connection between the relations represented by the predicate being
specified and other predicates.
%
These relations can be valid prior to or after execution.
%
In the predicate specification language they are pre- and
post-conditions and are expressed as \plqc{} properties.


A pre-condition is a property that only inspects its input.
%
It does not change the generated values to be applied to the specified
predicate.
%
Post-conditions can also use any of the specified parameters.
%
Since they are no longer used, it does not matter if they are changed by
the answer substitution.
%
Now we can describe the property relating the lengths of \yap{app/3}'s
parameters in a post-condition of a specification clause of the
respective type.
%
We identify the parameters of \yap{app} so that we can use them in the
post-condition as \yap{A},  \yap{B} and  \yap{C}.
%
\begin{yapcode}
 {app, 5} of_type (A-(listOf(int)), B-(listOf(int)), C-(variable))
   post_cond (length(A,K1), length(B,K2), length(C,K), K is K1+K2).
\end{yapcode}

