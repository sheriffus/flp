% -*- mode: latex; mode: folding -*-

\section{Case Studies}
\label{sec:case-studies}

%% \subsection{List Processing}
%% We start with small predicates and specifications.%%  in order to show the
%% %% tool.
%% %
%% These small examples demonstrate some of the potential of \plqc{}.
%% %
%% They help in revealing discrepancies between predicate's intended and
%% actual behaviour.


%{{{ List Reverse

\subsection{List Reverse}

Here we return to the first example given in \refSec{sec:properties}.
%
%% In general people have a conception of what is reversing the order of
%% elements, reversing a list is to observe the $i^th$ element of the original list as
%% the $(1+n-i)^th$ element of the reversed one for a list of size $n$.
%% %
%% There is also the idea of how to code such a procedure, independently of
%% the programming language.
%% %
%% In fact, there are quite a few ways to implement this procedure and we
%% discuss several implementations.% of the procedure.
%
%
We want to check attributes of a reversing procedure.
%% What we intend to check about our reverse procedures is the ability to
%% transform an input list into its reversed counterpart.
%
%% This implies that the property must have an input for random testing.
%irst, f
%% For the automatic generation of input
First, we must describe what is the input.
%
The procedure receives a list as first argument, and is polymorphic in
the type of the list's elements.
%% The procedure is polymorphic on the type of the elements of an
%% argument list
It is usually sufficient to check the behaviour for a
single type of elements.
%
Moreover, sometimes even a type with a finite number of values suffice,
but we can safely overestimate the size of the
type~\cite{Bernardy-testing-poly-prop}.
%
%% We choose to test the list predicates with lists of integer elements.
%
Therefore, we use the generator for integers, \yap{int}, as the elements
of the parametric list generator, \yap{listOf(int)}.



\begin{yapcode}
 rev_app([],[]).
 rev_app([X||XS], YS) :- rev_app(XS,ZS), append(ZS, [X], YS).
\end{yapcode}


For the previous implementation of reverse we can define the 
property in \refSec{sec:properties}.
%
The property underwent testing, passing all given tests.
%
%   ?- plqc:prologcheck(m:pcprop(double_rev_app), [{numtests, 1000}]), plqc:prologcheck(m:pcprop(double_rev_acc), [{numtests, 1000}]).
\begin{yapcode}
   ?- prologcheck(m:pcprop(d_rev_app)).
 OK: Passed 100 test(s).
\end{yapcode}
%
%% We can adapt the properties in \refSec{sec:properties} to both versions.
%% %
%% %% We do it by identifying the property names and called predicates
%% %% appropriately.
%% %
%% For the \yap{rev_app/2} predicate we have.
%% \begin{yapcode}
%%  pcprop(double_rev_app) :-
%%    plqc:pcforall(listOf(int), L, m:pcprop({dbl_rev_app_body, L})).
%% 
%%  pcprop({dbl_rev_app_body, L}) :- 
%%    m:rev_app(L, LR), !, m:rev_app(LR, L2), !, L == L2.
%% \end{yapcode}
%% %
%% The version for \yap{rev_acc/2} is obtained by changing the affix of
%% identifiers from \yap{app} to \yap{acc}
%% ,
%%           [{numtests, 1000}]
 %% OK: Passed 1000 test(s).
 %% yes


To check that the order is being reversed we can randomly choose an
element (or a %even a random
 set of elements) and inspect
 its position in the parameters.
%% if it is correctly positioned in the reversed list.
%
Choosing random elements prevent us from checking the whole list.
%
\begin{yapcode}
 pcprop(rev_app_i) :- plqc:pcforall(
     suchThat(structure({listOf(int), int}), m:valid_index),
     {L,I}, m:pcprop({double_rev_i_body, L, I}) ).
 valid_index({L, I}) :- length(L,X), I<X.

 pcprop({double_rev_i_body, L, I}) :- 
   m:rev_app(L, LR), length(L,X), Index is I+1, RevIndex is X-I,
   lists:nth(Index, L, Val), lists:nth(RevIndex, LR, Val).
\end{yapcode}
%
When performing a large number of tests this method should
 randomly choose enough indexes to 
give good
element coverage.
%
\begin{yapcode}
   ?- prologcheck(m:pcprop(rev_app_i)).
 OK: Passed 100 test(s).
\end{yapcode}

%% We start with
We have another implementation of reverse.
%, described later, 
While the first implementation uses concatenation, the following
builds the result with an accumulator via an auxiliary predicate.
%
%% With proper property labelling  and predicate calls we can define
%% \yap{pcprop(d_rev_app)} and \yap{pcprop(d_rev_acc)} to depict the
%% behaviour of \yap{rev_app/2} and \yap{rev_acc/2} respectively.
%
The same property is defined for the new implementation with the same
testing result.
\begin{yapcode}
 rev_acc([], LR, LR).
 rev_acc([X||XS], Acc, LR) :- rev_acc(XS, [X||Acc], LR).

 rev_acc(L, LR) :- rev_acc(L, [], LR).
\end{yapcode}


Since we have two implementations of the same concept we can explore
this by 
%% only performing tests on one version and
stating and testing a property comparing their behaviours.
%
\begin{yapcode}
 pcprop(eqv_acc_app) :-
   pcforall(listOf(int), L, (rev_acc(L,LR),rev_app(L,LR))).
\end{yapcode}
The comparison succeeds if both have the same behaviour.
%
\begin{yapcode}
   ?- prologcheck(m:pcprop(eqv_acc_app)).
 OK: Passed 100 test(s).
\end{yapcode}

%}}}

%{{{ append

\subsection{Append}
%% The %% \Prolog{}
%% implementation of the list concatenation predicate recurs on the first list
%% and the appended list parameters, leaving the second list uninspected.
%% %
Here we describe some properties of  \yap{append/3}:
%
%% \todo{no texto fica melhor   \yap{append/3} ou 'append' em texto normal?}
\begin{yapcode}
 append([], YS, YS).
 append([X||XS], YS, [X||AS]) :- append(XS, YS, AS).
\end{yapcode}
%% %
%% We check the behaviour of the \yap{append/3} predicate
%% through its specification with the predicate specification language.
%% %% presented in \refSec{sec:pred-spec}.
%% %


%% The most obvious way to use \yap{append/3} is by giving it two lists and expect
%% the resulting appended list.
%% %
%% So the type of such a specification clause is
%% (\yap{listOf(int),listOf(int),variable}).
%% %
%% We can assert that, in this \plqc{} type, parameters input modes are
%% (\yap{ground, ground, var}) and the output modes (\yap{ground, ground,
%%   ground}).
%% %
%% It should also be the case that this use of the predicate behaves as a
%% function, expecting exactly one answer.
%% %
\yap{append(A,B,C)} is used in a functional way in many programs,
i.e. by giving it two lists as input and getting their concatenation as
output.
%
This behaviour is specified in \plqc{} as:
 %% (plqc:listOf(int), plqc:listOf(int), plqc:variable)
\begin{yapcode}
 append of_type (A-(listOf(int)), B-(listOf(int)), C-(variable))
   where (i(g, g, v), o(g, g, g))  has_range {1,1}.
\end{yapcode}
%
Prologchecking this specification clause bears no surprises.
%
\begin{yapcode}
   ?- prologcheck(m:pcprop(spec_append)).
 OK: Passed 100 test(s).
\end{yapcode}


%% Although
\yap{append/3} %% has an intended usage, it
may be %% successfully
also
used in other situations.
%
For example, one can use it to create an open list, by %% giving a variable
%% in place of the second list, which remains uninspected.
calling it with a variable in the second argument.
%
The result is a list with the ground elements of the first list and the
second list variable as the tail, therefor it is neither ground nor
variable.
%% %
%% This usage also behaves as a function, since the potentially mutating
%% part of the input is not a target of pattern matches.
%
\begin{yapcode}
 {append, 1} of_type (A-(listOf(int)), B-(variable), C-(variable))
   where (i(g, v, v), o(g, v, ngv))  has_range {1,1}.
\end{yapcode}
%
Testing this specification clause reveals that the \emph{out} part of
the directionality is not satisfied.
%   ?- plqc:prologcheck(m:pcprop(spec_append_1)).
\begin{yapcode}
  ?- prologcheck(m:pcprop(spec_append_1), [noshrink]).
 {failed_out_modes,[[o,g,v,ngv]], [[],_10258,_10258]}
 Failed: After 3 test(s).
 Counterexample found: [[[],_10258,_10260]] 
\end{yapcode}
%
The counterexample shows that when the first argument is the empty
list, %% and the other two variables,
the output modes do not respect %% comply with
the specification %% .
%% % when L1 is [], LApp is L2, i.e. var
%% %
%% Upon closer inspection it is noted that
because
the base case of the recursion
%% on the first argument simply
unifies the second and third parameters.
%% when it matches an empty list.
%
%% There are two %% simple
%% ways of solving this problem.
%% %
%% One is to split the specification clause between input types that only
%% have empty lists or non-empty lists separately.
%% %
%% The other
One way to solve it 
is to add the missing directionality \yap{(i(g, v, v), o(g, v, ngv)), o(g,v,v)}.
%
%% The correct choice in general is to split the input types, since this is
%% a matter between disjoint sets of terms.
%% %
%% Multiple output directionalities are mainly intended for multiple modes
%% %% of the parameters
%% of multiple answers.
%% %
%% Given the simplicity of the example we decided to add a directionality.
%% %
%% \begin{yapcode}
%%    where (i(g, v, v), o(g, v, ngv)), o(g,v,v)
%% \end{yapcode}


%% \begin{yapcode}
%%  {m:append, 2}
%%    of_type (A-(plqc:variable),
%%      B-(plqc:listOf(int)), C-(plqc:variable))
%%    where (i(v, g, v), o(g, g, g), o(ngv, g, g))
%%    has_range {1,1}.
%% \end{yapcode}
%%  % default 1-inf

%}}}

\subsection{AVL Trees}

We have described AVL properties and performed black-box testing of an
implementation of AVL trees in a \Yap{} module, \yap{avl.yap} with
\plqc{}\footnote{All the details can be found in the tool's website.}.
%%
Due to space restrictions we only present a general description of the
process and its results. 


The module interface is small, with predicates to create an empty
tree, insert an element and look up an element, respectively
\yap{avl_new/1}, \yap{avl_insert/4} and \yap{avl_lookup/3}.
%
When performing this kind of test one does not simply test individual
predicates but rather usages of the module.
%
To do this we must be able to create sequences of interface
calls and inspect intermediate results for compliance with AVL
invariants.
%
Knowledge about the shape of input/output terms can be gathered manually
if it is not previously known.


\paragraph{\bf Generator}

Creating a valid sequence of interface calls is not difficult, but
requires attention to detail.
%
First, we only want to generate valid sequences to save effort of
checking validity and not suffer from sparse valid values.
%
Using the same module implies the existence of two sets of important
terms: key terms, and value terms, which we parametrise as generators.
%
In order to test the correct failure of wrong look-ups, a set of values
for failed look-ups disjoint from the regular values is also
parametrised.


The generator starts by creating the tree, independently of the
size parameter, using \yap{avl_new/1}.
%
This implies that when size is 0 an empty AVL-tree is still created.
%
Thus, we always append the tree creation to a sequence of calls to
insert and look-up values.
%
Each element of the sequence is obtained by randomly choosing between
insert and look-ups.


Look-ups are divided between valid look-up and invalid look-up.
%
Valid look-ups are only generated after the corresponding insert and
invalid look-ups are based in a set of values that is never inserted.
%
Valid look-ups can be further distinguished between looking up a
key-value pair and looking up a key and retrieving its value.
%
These elements are  branded by a command identifier to recognise their
correct behaviour during testing.


%% The relative probabilities are such that we get a big variety of commands within
%% relatively small sequences.



%}}}

%% \paragraph{\bf }

%% \subsubsection*{Property}
\paragraph{\bf Property}

%{{{ generic property

The definition of the AVL property depends on several factors.
%
It is necessary to have operations to extract information from trees,
such as current node's key, key comparison, left and
right sub-trees and empty tree test.


A tree may be empty, in which case it is an AVL tree of height 0.
%
In the case of a non-empty tree we retrieve its key and sub-trees.
%
They are used in recursive checks of the property.
%
The recursive calls accumulate lists of keys that should be greater and
less then the keys of the tree.
%
If the sub-trees are individually compliant with the property, we
proceed with the last check, comparing the returned heights for
balance and computing the current tree height.
%
This is how the property is outlined in \plqc{}.
%

\pagebreak 
      %% ((forall(member(X, Ls), cmpKeys(X, K, lte))) -> true; error1),
      %% ((forall(member(X, Gs), cmpKeys(X, K, gt))) -> true; error2))
   %% pc_and (( abs(Hl-Hr) =< 1 -> true; error3), H is 1+max(Hl,Hr))),
\begin{yapcode}
pcprop({avl, T, Gs, Ls, H}) :- pcif( (not isNil(T)),
 ((getKey(T, K), left(T, L),  right(T, R),
      ((forall(member(X, Ls), cmpKeys(X, K, gt))) -> error1),
      ((forall(member(X, Gs), cmpKeys(X, K, lte))) -> error2))
   pc_and pcprop({avl, L, [Key||Gt], Lt, Hl})
   pc_and pcprop({avl, R, Gt, [Key||Lt], Hr})
   pc_and (( abs(Hl-Hr)>1 -> error3), H is 1+max(Hl,Hr))),
 (H = 0) ).
\end{yapcode}
%
We complete the property by inserting it into a loop that consumes the
operations in the quantified module uses.



\refTabI{tab:avl-tests} summarises some relevant results of our tool
applied to the AVL library.
%
Each line corresponds to a different module version: line 1 to the
original version; line 2 to a bug in the re-balancing strategy inserted
by the tester; line 3 to a different bug also in the re-balancing
strategy inserted by someone that was not involved with the tests.
%
The column \emph{Tests} is the number of tests needed to achieve a
particular counter-example.
%
For the purpose of readability we will represent only the key and value
arguments of the AVL operations.
%
%% \todo{frase longa dividida em duas frases}
Thus consider \yap{i(N,V)} as insert an
element with key \yap{N} and value  \yap{V}, and \yap{l(N,V)} as look up
the pair \yap{(N,V)} in the tree.
%
Note that the counter-example found in the original version corresponds
to an unspecified behaviour in the case of two insertions with the same key.
%% \todo{se calhar nao \'e 'case', nao percebo a letra do mario...}
%
After several runs of the tool (10 for the first bug and 20 for the
second) we managed to find a pattern on the counter-examples which led
to the identification of the pathological behaviour caused by the bugs.


\begin{table}
  \centering
  \begin{tabular}{||c||c||l||}
    \hline
    Version    &  Tests   &  Counter-example
    \\ \hline
    Original   &  732     &  \yap{i(1,a), i(1,b), l(1,b)}
    \\ \hline
    Error 1    &  51      &  \yap{i(3,a), i(1,b), i(2,c)}
    \\ \hline
    Error 2    &  213     &  \yap{i(5,a), i(2,b), i(3,c), i(4,d), i(1,e)}
    \\ \hline
  \end{tabular}
  \caption{{\tt avl} testing summary.}
  \label{tab:avl-tests}
\end{table}


%% We run 1000 tests and no bug is detected, as expected for a relatively
%% smaller library module.
%% %
%% The only unspecified behaviour we discover is about two insertions under the
%% same key, and a look-up based on the discarded insertion.
%% %
%% This means that the key generator is not sparse enough for 1000 test,
%% where the size of generated values grows and the probability of such a
%% combination appearing starts to show.

%}}}

%{{{ wrong 1

%% To explore the tool potential we inserted a bug in the module.
%% %
%% We changed a line in the table that states how the tree will be
%% re-balanced upon insertion of a new element.
%% %
%% We changed the information stating that a perfectly balanced tree leans
%% left after inserting an element that increases the left sub-tree height
%% to ignore the balance change.
%% %
%% Testing this version of the implementation shows a counterexample after
%% less than 100 test cases on average.
%% %
%% The counterexamples found are command sequences where three inserts are
%% given in the key order $3, 1, 2$
%% %
%% Another failing sequence of insertions is in the key order $1, 3, 2$.
%% %
%% The conclusion we can get from the counterexamples is that the
%% balancing or balance calculation of the tree is probably failing.

%}}}

%{{{ wrong 2

%% A second bug is purposely inserted by someone that is not involved
%% with the tests.
%% %
%% From the perspective of the tester we start with the tests.
%% %
%% Counterexamples are found in average after at least 200 test cases.
%% %
%% The minimal shape found are sequences of 5 insertions.
%% %
%% There are two families of counterexamples
%% %
%% One is such that the first three elements inserted are the keys $1, 2,
%% 4$, in any order, followed by key $5$ and finally key $3$.
%% %
%% In the second the first keys are $2, 4, 5$, also in no particular order,
%% followed by $3$ and $1$.
%% %
%% These sequences fail when trying to complete the second level of one of
%% the root's sub-trees.
%% %
%% Furthermore, it happens only if the completion takes the order
%% right-left.


%% There are no other details we could retrieve information from.
%% %
%% As far as black-box testing is concerned the origin of the error cannot
%% be pinpointed.
%% %
%% Although, we can infer we are dealing with a balance issue, since it can
%% appear with only insertions.
%% %
%% We can go as far as saying that the problem appears to be in a left
%% insertion, not noticeable in the nodes after the root of the tree.


%% Inspecting the source we can see that the error was caused by another
%% change to the balance table changed for the first error.
%% %
%% The bug inserted forces a re-balance of an already balanced tree in the
%% speculated situation - an insertion to the left filling where there is
%% already a value to the right.

%}}}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555


%% \subsection{AVL Trees}
%% AVL trees are implemented in a \Yap{} module,  \yap{avl.yap}, making it interesting to
%% %% test in order to
%% show black-box testing with \plqc{}.
%% %
%% Its interface is small, with predicates%% only three predicates, 
%% to create an empty
%% tree, insert an element and look up an element, respectively
%% \yap{avl_new/1}, \yap{avl_insert/4} and \yap{avl_lookup/3}.
%% %
%% %% With only this interface and knowledge about the trees' shape we can
%% %% test weather the module implements AVL trees correctly.
%% %
%% When performing this kind of test one does not simply test individual
%% predicates, we test usages of the module.
%% %
%% %% In order t
%% To do this we must be able to create sequences of interface
%% calls and inspect intermediate results.
%% %
%% %% To inspect intermediate results it is necessary to perform some
%% %% interface calls and study the result terms.
%% Knowledge about the shape of trees is gathered by manual testing.

%% \subsubsection*{Generator}

%{{{

%% Creating a valid sequence of interface calls is not difficult, but
%% requires attention to detail.
%% %
%% First, we only want to generate valid sequences
%% %
%% %% This is important
%% to save effort of checking validity and not suffer
%% from sparse valid values.
%% %
%% Usages of the module have two sets of important terms: key
%% terms, and value terms.
%% %
%% We decided to parametrise these sets as generators.
%% %
%% %% Along with generators for keys and tree values
%% We also parametrise a
%% generator for failed look-ups that must be disjoint from the generator
%% of values.
%% %
%% In this generator we start by creating the tree, independently of the
%% size parameter.
%% %
%% This implies that when size is 0 an empty AVL-tree is still created.
%% %
%% Thus, we always append the tree creation to a sequence of calls to insert and look-up
%% values.
%% %
%% \begin{yapcode}
%%  genAvl(KeyGen, ValGen, FGen, Calls, Size) :-
%%    Calls = [(avl:avl_new) || Cs1],
%%    genAvlCmds(KeyGen, ValGen, FGen,
%%               [], Cs1, Size).
%% \end{yapcode}


%% %% Generation of commands to insert and look-up values is passed the
%% %% information about keys and values.
%% %% %
%% Each element of the sequence is obtained by randomly choosing between insert, valid look-up and invalid
%% look-up.
%% %
%% After an insert command is added, the inserted key-value is saved in a
%% look-up list to draw future valid look-ups from.
%% %
%% Valid look-ups are not generated if the look-up list is empty.
%% %% %
%% %% When the size parameter reaches zero, we generate an empty list of
%% %% commands.
%% %% %
%% %% Otherwise a command is generated and the size is decreased at least by
%% %% one and at most to half.
%% %
%% Commands are generated without the context tree, which is managed by
%% the property.
%% %
%% \begin{yapcode}
%%  genAvlCmds(KeyGen, _ValGen, _FGen,
%%             _Lookups, [], 0) :- !.
%%  genAvlCmds(KeyGen, ValGen, FGen,
%%             Lookups, Cs, Size) :-
%%    genCmdHead(KeyGen, ValGen, FGen,
%%               Lookups, X, Size),
%%    call(KeyGen, Key, Size),
%%    (X = {i, Val},
%%     Cs = [{i, avl:avl_insert(Key, Val)}||CsS],
%%     NewLookups = [ {Key,Val} || Lookups]
%%    ;
%%     X = {fl, {FK, FV}},
%%     Cs = [{fl, avl:avl_lookup(FK, FV)}||CsS]
%%    ;
%%     (X = {l1, {K, V}}, Lx=l1
%%     ; X = {l2, {K, V}}, Lx=l2),
%%     Cs = [{Lx, avl:avl_lookup(K, V)}||CsS]
%%    ),
%%    MinSize is Size // 2, MaxSize is Size-1,
%%    choose(MinSize, MaxSize, NewSize, Size),
%%    genAvlCmds(KeyGen, ValGen, FGen,
%%               NewLookups, CsS, NewSize)
%%  .
%% \end{yapcode}


%% Choosing a single command follows a couple of restrictions.
%% %
%% If the generator for failing look-ups is missing, these commands will
%% not be generated.
%% %
%% If the list of look-ups is empty, valid look-ups will not be generated.
%% %
%% Valid look-ups can take two forms: checking if the key-value is in the
%% tree and asking for the value corresponding to some key.
%% %
%% All commands are branded by a command identifier, making it possible to
%% distinguish between different kinds of look-up.
%% %
%% The possible choices are bundled in a \yap{frequency} generator.
%% %
%% The relative probabilities are such that we get a big variety of commands within
%% relatively small sequences.
%% %
%% \begin{yapcode}
%%  genCmdHead(KeyGen, ValGen, none,
%%            [], X, Size) :- !,
%%    plqc:structure({plqc:value(i), ValGen},
%%                   X, Size).
%%  genCmdHead(KeyGen, ValGen, none,
%%             Lookups, X, Size) :- !,
%%    Insert =
%%      plqc:structure({plqc:value(i), ValGen}),
%%    Lookup1 = plqc:structure(
%%      {plqc:value(l1), plqc:elements(Lookups)}),
%%    Lookup2 = plqc:structure(
%%      {plqc:value(l2), plqc:elements(Lookups)}),
%%    plqc:frequency([{6,Insert}, {2,Lookup1},
%%        {2,Lookup2}], X, Size).
%%  genCmdHead(KeyGen, ValGen, FGen,
%%             [], X, Size) :- !,
%%    Insert = (...),
%%    FailLookup = plqc:structure(
%%      {plqc:value(fl), {KeyGen, FGen}}),
%%    plqc:frequency(
%%      [{9,Insert}, {1, FailLookup}], X, Size).
%%  genCmdHead(KeyGen, ValGen, FGen,
%%             Lookups, X, Size) :-
%%    Insert = (...), FailLookup = (...),
%%    Lookup1 = (...), Lookup2 = (...),
%%    plqc:frequency([{6,Insert}, {2,Lookup1},
%%       {2,Lookup2}, {1, FailLookup}], X, Size).
%% \end{yapcode}
%% %% \begin{yapcode}
%% %     plqc:structure({plqc:value(i), ValGen}),
%% %     plqc:structure({plqc:value(i), ValGen}),
%% %     plqc:structure({plqc:value(fl),
%% %                     {KeyGen, FGen}}),
%% %     plqc:structure({plqc:value(l1),
%% %                     plqc:elements(Lookups)}),
%% %     plqc:structure({plqc:value(l2),
%% %                     plqc:elements(Lookups)}),
%% %% \end{yapcode}


%% Together with the generators for module usages we need the generators
%% for keys and values.
%% %
%% Keys are integers between $0$ and $50000$, a large enough interval to
%% generate a fair amount of unique keys in smaller test cases.
%% %
%% Values are non-negative integers bound by the size.
%% %
%% To construct a disjoint generator we use singleton lists with elements
%% given by the value generator.
%% \begin{yapcode}
%%  genKey(Key, Size) :-
%%    plqc:choose(0, 50000, Key, Size).

%%  genVal(Val, Size) :-
%%    plqc:choose(0, Size, Val, Size).

%%  genFVal([Val], Size) :-
%%    plqc:choose(0, Size, Val, Size).
%% \end{yapcode}

%}}}


%% \subsubsection*{Property}

%{{{ generic property

%% The avl property depends on several factors.
%% %
%% It is parame\-trised by the tree to check and by operations to extract
%% information from that tree.
%% %
%% These operation consist of: current node's key; key comparison; left and
%% right sub-trees; empty tree test.
%% %
%% A side effect of the property is returning the height of the tree.
%% %
%% The empty tree test is a callable term that checks if the tree in the
%% first argument is empty and unifies the second argument to the
%% appropriate truth value.
%% %
%% Key comparison is callable with three parameters: first key, second key
%% and result.
%% %
%% The result of the comparison reflects the relation between the given
%% keys : \yap{lt, gt, eq, lte, gte}.
%% %
%% \begin{yapcode}
%%  pcprop({avl, (tree, T), (height, H),
%%       (curr_key, GetKey), (cmp_key, CmpKeys),
%%       (left, L), (right, R),
%%       (is_nil, IsNil)}) :- 
%%    pcif(...).
%% \end{yapcode}


%% A tree may be empty, in which case we just unify the correct height.
%% %
%% In the case of a non-empty tree we retrieve its key and sub-trees.
%% %
%% They are used in recursive checks of the property.
%% %
%% The recursive calls are for a different predicate, accumulating lists of
%% keys that should be greater of less then the keys of the tree.
%% %
%% After checking the sub-trees, the returned heights are compared for
%% balance and the current tree height computed.
%% %
%% \begin{yapcode}
%%    pcif( (call(IsNil, T, V), V = false)
%%    ,((call(GetKey, T, Key),
%%        call(L, T, LT),  call(R, T, RT))
%%    pc_and
%%      pcprop({avl, (gt, [Key]), (lt, []),
%%  (tree, LT), (height, LH),
%%  (curr_key, GetKey), (cmp_key, CmpKeys),
%%  (left, L), (right, R), (is_nil, IsNil)})
%%    pc_and
%%      pcprop({avl, (gt, []), (lt, [Key]),
%%  (tree, RT), (height, RH),
%%  (curr_key, GetKey), (cmp_key, CmpKeys),
%%  (left, L),(right, R),(is_nil, IsNil)})
%%    pc_and
%%      (( abs(LH-RH) =< 1, !
%%      ; print(height_mismatch), nl, fail),
%%      H is 1+ max(LH,RH))
%%    ),
%%    (V=false, H = 0) )
%% \end{yapcode}
%% %% \begin{yapcode}
%% %%    pcif( (...)
%% %%    ,((call(GetKey, T, Key),
%% %%        call(L, T, LT),  call(R, T, RT))
%% %%    pc_and
%% %%      (...)
%% %%    pc_and
%% %%      (...)
%% %%    pc_and
%% %%      (...)
%% %%    ),
%% %%      (...) )
%% %% \end{yapcode}
%% %
%% %% \begin{yapcode}
%% %%    pcif( (...)
%% %%    ,( (...)
%% %%    pc_and
%% %%      pcprop({avl, (gt, [Key]), (lt, []),
%% %%  (tree, LT), (height, LH),
%% %%  (curr_key, GetKey), (cmp_key, CmpKeys),
%% %%  (left, L), (right, R), (is_nil, IsNil)})
%% %%    pc_and
%% %%      pcprop({avl, (gt, []), (lt, [Key]),
%% %%  (tree, RT), (height, RH),
%% %%  (curr_key, GetKey), (cmp_key, CmpKeys),
%% %%  (left, L),(right, R),(is_nil, IsNil)})
%% %%    pc_and
%% %%      (( abs(LH-RH) =< 1, !
%% %%      ; print(height_mismatch), nl, fail),
%% %%      H is 1+ max(LH,RH))
%% %%    ),
%% %%      (...) )
%% %% \end{yapcode}


%% The accumulating version of the property receives as extra arguments the
%% lists of keys in the path up to the root that are greater and less then
%% the current key.
%% %
%% This order criterion is what differentiates the accumulating property.
%% %
%% It is checked for the current key which is then added to the appropriate
%% accumulators in the recursive calls.
%% % (tree, T),
%% %       (height, H), (curr_key, GetKey),
%% %       (cmp_key, CmpKeys), (left, L),
%% %       (right, R), (is_nil, IsNil)
%% \begin{yapcode}
%%  pcprop({avl, (gt, GTS), (lt, LTS), ...}) :-
%%    pcif(
%%      (...)
%%    ,(
%%      (call(GetKey, T, Key), call(L, T, LT),
%%       call(R, T, RT),
%%       (forall(member(X, LTS),
%%        call(CmpKeys, X, Key, lte)), !
%%       ; print(avl_key_not_inorder1), nl, fail),
%%       (forall(member(X, GTS),
%%        call(CmpKeys, X, Key, gt)), !
%%       ; print(avl_key_not_inorder2), nl, fail))
%%    pc_and (...)
%%    pc_and (...)
%%    pc_and (...)
%%    ),
%%      (...)
%%    ).
%% \end{yapcode}


%% To access the fields of trees generated and maintained by \yap{avl.yap}
%% we examine the product of some calls.
%% %
%% After inspecting the resulting trees we implement the operations needed
%% for the generic property.
%% %
%% We complement this with the key comparison and empty tree check.
%% %
%% \begin{yapcode}
%%  get_key(avl(_Left, Key, _Val,
%%              _Balance, _Right), Key).
%%  cmp_keys(K1, K2, Cmp) :-
%%    print({K1, K2}),
%%  ( K1 < K2, Cmp = lt
%%  ; K1 =< K2, Cmp = lte
%%  ; K1 =:= K2, Cmp = eq
%%  ; K1 >= K2, Cmp = gte
%%  ; K1 > K2, Cmp = gt
%%  ).
%%  left( avl(Left, _Key, _Val,
%%            _Balance, _Right), Left).
%%  right( avl(_Left, _Key, _Val,
%%             _Balance, Right), Right).
%%  is_nil( avl(_Left, _Key, _Val,
%%              _Balance, _Right), false).
%%  is_nil([], true).
%% \end{yapcode}

%}}}


%% With the generator, generic property, and access predicates we proceed to
%% define the %% top property we will
%% main test.
%% %
%% We quantify over module uses, which are processed in its body.
%% %
%% The body is composed by a start and a loop, dealing respectively with
%%  tree creation and insert/look-up commands.
%% %
%% The start consumes the tree creation command and checks if the generated
%% tree is an empty avl tree.
%% %
%% The resulting empty tree is fed to the loop with any remaining interface
%% calls.
%% %
%% The loop consumes the command list a command at a time.
%% %
%% An insert command requires that the resulting tree be checked for the
%% avl property.
%% %
%% %% \end{yapcode}
%% %% %
%% %% \begin{yapcode}
%% %% \end{yapcode}
%% %% %
%% %% %             (height, H),
%% %% %             (curr_key, avlTest:get_key),
%% %% %             (cmp_key, avlTest:cmp_keys),
%% %% %             (left, avlTest:left),
%% %% %             (right, avlTest:right),
%% %% %             (is_nil, avlTest:is_nil)
%% %% \begin{yapcode}
%% %% \end{yapcode}
%% %
%% Looking-up a key-value depends on the given label.
%% %
%% The labels \yap{l1} and \yap{l2} indicate valid look-ups.
%% %
%% In \yap{l1} the key-value look-up is performed directly, in contrast
%% with \yap{l2} which looks-up the key and matches the returning value
%% against the expected value.
%% %%  %% (height, _H),
%% %%  %%           (curr_key, avlTest:get_key),
%% %%  %%           (cmp_key, avlTest:cmp_keys),
%% %%  %%           (left, avlTest:left),
%% %%  %%           (right, avlTest:right),
%% %%  %%           (is_nil, avlTest:is_nil)
%% %%    %% pcprop({avl, (tree, Tree), (...) })
%% %%    %%   pc_and
%% %% \begin{yapcode}
%% %% \end{yapcode}
%% %%  %% (height, _H),
%% %%  %%           (curr_key, avlTest:get_key),
%% %%  %%           (cmp_key, avlTest:cmp_keys),
%% %%  %%           (left, avlTest:left),
%% %%  %%           (right, avlTest:right),
%% %%  %%           (is_nil, avlTest:is_nil)
%% %%    %% pcprop({avl, (tree, Tree), (...)})
%% %%    %%   pc_and
%% %% \begin{yapcode}
%% %% \end{yapcode}
%% %
%% Invalid look-ups are validated by their execution failure.
%% %%  %% (height, _H),
%% %%  %%           (curr_key, avlTest:get_key),
%% %%  %%           (cmp_key, avlTest:cmp_keys),
%% %%  %%           (left, avlTest:left),
%% %%  %%           (right, avlTest:right),
%% %%  %%           (is_nil, avlTest:is_nil)
%% %%    %% pcprop({avl, (tree, Tree), (...)})
%% %%    %%   pc_and
%% %% \begin{yapcode}
%% \begin{yapcode}
%%  pcprop(avlUses) :-
%%    pcforall(avlTest:genAvl(avlTest:genKey,
%%               avlTest:genVal, avlTest:genFVal),
%%             Calls, pcprop({avlUses, Calls})).

%%  pcprop({avlUses, [(avl:avl_new)||Calls]}) :-
%%    call(avl:avl_new(Tree))
%%   pc_and
%%    pcif(
%%      pcprop({avl, (tree, Tree), (height, 0),
%%                   (curr_key, avlTest:get_key),
%%                   (cmp_key, avlTest:cmp_keys),
%%                   (left, avlTest:left),
%%                   (right, avlTest:right),
%%                   (is_nil, avlTest:is_nil)})
%%    ,(pcprop({avlUses, Tree, Calls}))
%%    ,(print(avl_new_fail_invariant), nl, fail)).
%%  pcprop({avlUses, Tree, []}).
%%  pcprop({avlUses, Tree,
%%       [{i,avl:avl_insert(Key,Val)}||Calls]}) :-
%%    call(avl:avl_insert(Key,Val),
%%         Tree, ContinuationTree)
%%      pc_and
%%    pcif(
%%      pcprop({avl, (tree, ContinuationTree),
%%              (...) })
%%    , (pcprop({avlUses, ContinuationTree,
%%               Calls}))
%%    , (print(avl_insert_fail_invariant),
%%       nl, fail)).
%%  pcprop({avlUses, Tree,
%%       [{l1,avl:avl_lookup(Key,Val)}||Calls]}) :-
%%    ( call(avl:avl_lookup(Key,Val), Tree)
%%    ; print(avl_lookup_not_found_fail),
%%      nl, fail)
%%      pc_and
%%    pcprop({avlUses, Tree, Calls}).
%%  pcprop({avlUses, Tree,
%%       [{l2,avl:avl_lookup(Key,Val)}||Calls]}) :-
%%    (( call(avl:avl_lookup(Key,XVal), Tree)
%%     ; print(avl_lookup_not_bound_fail),
%%      nl, fail),
%%     XVal = Val)
%%      pc_and
%%    pcprop({avlUses, Tree, Calls}).
%%  pcprop({avlUses, Tree,
%%       [{fl,avl:avl_lookup(Key,Val)}||Calls]}) :-
%%    ( call(avl:avl_lookup(Key,Val), Tree),
%%      print(avl_lookup_found_fail), nl, !, fail
%%    ; true)
%%      pc_and
%%    pcprop({avlUses, Tree, Calls}).
%% \end{yapcode}
%% %% %
%% %% Note that the labelled property is connected with a \yap{pc_and} operator
%% %% where instead it could be in the place of the \yap{true} \Prolog{}
%% %% built-in goal.
%% %% %
%% %% This is due to the fact that \plqc{} does not inspect \Prolog{} goals
%% %% and connectives.


%% It is to be expected that the module satisfy the properties.
%% %
%% We run 1000 tests with the test number option.
%% %
%% In one of the testing suits, a counterexample popped up.
%% %
%% We repeat the tests until we get enough counterexamples to examine.
%% %
%% Inspecting the counterexamples we find the reason for the failure.
%% %
%% We discover that the counterexamples found have two insertions under the
%% same key, where the second value is discarded, and a look-up based on
%% the second insertion.
%% %
%% This means that the key generator is not sparse enough for 1000 test,
%% where the size of generated values grows and the probability of such a
%% combination appearing starts to show.
%% %
%% We decide to do nothing about it since it is a very uncommon event.
%% %
%% We could have increased the interval for the generation of keys, which
%% would be a quick fix yet would not fix the specification bug, instead it would just
%% make it less common.
%% %
%% The best way to fix the specification is to not adding existing keys to
%% the look-ups list in the command generator or enforcing the picking of
%% the first insertion of a certain key.
%% %
%% The latter is possible by choosing the last entry in the look-ups list
%% with the key in question.
%% %
%% \begin{yapcode}
%%    ?- plqc:prologcheck(
%%                 avlTest:(pcprop(avlUses)),
%%                 [{numtests, 1000}] ).
%%  avl_lookup_not_bound_fail
%%  !
%%  Failed: After 732 test(s).
%%  Counterexample found: [[avl:avl_new,
%%      {i,avl:avl_insert(45157,19)}, ...
%%      {i,avl:avl_insert(45157,0)}, ...
%%      {l2,avl:avl_lookup(45157,0)}]] 
%% \end{yapcode}


%% %% In order to  assess the tool and the specification in broader terms we
%% %% insert two bugs and test the two erroneous versions of the module.
%% %% %
%% %% The first bug was introduced by the tester and the second by another
%% %% programmer.
%% %% %
%% %% This still fits the goal of black-box testing because the actual tests
%% %% are still performed without knowledge of the module's source.
%% %% %
%% %% It is the same as testing different closed implementations.


%{{{ wrong 1

%% To explore the tool potential we inserted a bug.
%% %
%% We changed a line in the table that states how the tree will be
%% re-balanced upon insertion of a new element.
%% %
%% The first arguments of the table are input.
%% %
%% The first is the state of the balance, and the second where we insert
%% the new element.
%% %
%% The other three columns state if the new state of the tree is balanced,
%% if the tree increased in height, and if the tree needs further
%% re-balancing.
%% %
%% For example, the two first rows describe a situation where a totally
%% balanced tree receives a new element.
%% %
%% The tree will increase in size and will not be balanced, but we cannot
%% improve on that, so no re-balancing will be needed.

%% \begin{yapcode}
%%  table( -  , left   , -  , yes  , no   ).
%% % table( -  , left   , <  , yes  , no   ).
%%  table( -  , right  , >  , yes  , no   ).
%%  table( <  , left   , -  , no   , yes  ).
%%  table( <  , right  , -  , no   , no   ).
%%  table( >  , left   , -  , no   , no   ).
%%  table( >  , right  , -  , no   , yes  ).
%% \end{yapcode}
%% %
%% %
%% Testing this version of the implementation shows a counterexample after
%% less than 100 test cases on average.
%% %
%% %% \end{yapcode}
%% %
%% The counterexamples found are command sequences where three inserts are
%% given in the key order $3, 1, 2$
%% %
%% What happens is that after inserting the second value, the tree is
%% unbalanced.
%% %
%% This information is erased by the bug, which will allow any number of
%% left insertions.
%% %
%% Another failing sequence of insertions is in the key order $1, 3, 2$.
%% %
%% Here the last call will not even give a wrong result, it will simply
%% fail at the last insertion.
%% %
%% This is noticed in this example by the lack of an error message from the
%% property.
%% %
%% %% \begin{yapcode}
%% %
%% The only conclusion we can get from the counterexamples is that the
%% balancing of the tree is probably failing when the tree is unbalanced to
%% the right and the sub-tree to the left.
%% \begin{yapcode}
%%    ?- plqc:prologcheck(
%%              avlTest:(pcprop(avlUses))).
%%  height_mismatch
%%  avl_insert_fail_invariant
%%  !
%%  Failed: After 51 test(s).
%%  Counterexample found:
%%    [[avl:avl_new,
%%      {i,avl:avl_insert(22340,0)},
%%      {i,avl:avl_insert(1488,1)},
%%      {i,avl:avl_insert(8952,0)}]] 
%%  yes
%%    ?- plqc:prologcheck(
%%              avlTest:(pcprop(avlUses))).
%%  Failed: After 66 test(s).
%%  Counterexample found:
%%    [[avl:avl_new,
%%      {i,avl:avl_insert(9919,1)},
%%      {i,avl:avl_insert(39796,0)},
%%      {i,avl:avl_insert(18564,1)}]]
%%  yes
%% \end{yapcode}

%}}}

%{{{ wrong 2

%% The second bug is purposely inserted by someone that is not involved
%% with the tests.
%% %
%% We examine and write about it as such, starting with the tests.
%% %
%% Counterexamples are found in average after at least 200 test cases.
%% %
%% The minimal shape found are sequences of 5 insertions.
%% %
%% There are two families of counterexamples
%% %
%% One is such that the first three elements inserted are the keys $1, 2,
%% 4$, in any order, followed by key $5$ and finally key $3$.
%% %
%% In the second the first keys are $2, 4, 5$, also in no particular order,
%% followed by $3$ and $1$.
%% %
%% \begin{yapcode}
%%    ?- plqc:prologcheck(
%%                avlTest:(pcprop(avlUses)),
%%                [{numtests, 1000}] ).
%%  Failed: After 213 test(s).
%%  Counterexample found:
%%    [[avl:avl_new,
%%      {i,avl:avl_insert(42290,9)},
%%      {i,avl:avl_insert(17481,5)},
%%      {i,avl:avl_insert(19130,5)},
%%      {i,avl:avl_insert(18001,3)},
%%      {i,avl:avl_insert(4284,1)}]]
%%  yes
%% \end{yapcode}
%% %
%% These sequences fail when trying to complete the second level of one of
%% the root's sub-trees.
%% %
%% Furthermore, it happens only if the completion takes the order
%% right-left.


%% There are no other details we could retrieve information from.
%% %
%% As far as black-box testing is concerned the origin of the error cannot
%% be pinpointed.
%% %
%% Although, we can infer we are dealing with a balance issue, since it can
%% appear with only insertions.
%% %
%% We can go as far as saying that the problem appears to be in a left
%% insertion, not noticeable in the nodes after the root of the tree.


%% Inspecting the source we can see that the error was caused by another
%% change to the balance table changed for the first error.
%% %
%% In this case, the following change was performed.
%% %
%% \begin{yapcode}
%%  table( >   , left   , -   , yes    , no ).
%%  % table( >   , left   , -   , no    , no ).
%% \end{yapcode}
%% %
%% This forces a re-balance of an already balanced tree in the speculated
%% situation - an insertion to the left filling where there is already a
%% value to the right.

%}}}




%% %% \subsection{red-black Trees}

