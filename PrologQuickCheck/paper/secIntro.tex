% -*- mode: latex; mode: folding -*-

\section{Introduction}
\label{sec:intro}
%{{{ introduction text

%% \todo{Whispec: White-box Testing of Libraries
%% Using Declarative Specifications}
%% \todo{Ranking Programs using Black Box Testing}
%% \todo{Finding Race Conditions in Erlang with QuickCheck and
%% pulse -- system }
%% \todo{Property-based testing for functional programs, Nicholas
%%   Smallbone, Lic Thesis at Chalmers -- mentions white,
%%   black and system, includes two previous papers}
%% \todo{QuickCheck-Style Testing of
%% Embedded Software using the PropEr
%% Framework -- system}
%% \todo{Testing Telecoms Software with Quviq QuickCheck}
%% \todo{Testing Erlang Data Types with Quviq quickcheck}
%% \todo{Testing Java with QuickCheck}
%% \todo{Testing Erlang Refactorings with QuickCheck}
%% \todo{Early Fault Detection with Model-Based Testing}
%% \todo{Automated, deterministic testing versus stochastic
%% testing using Quickcheck -- MSc of Fredrik Hoback at KTH -- conformance}
%% \todo{Ranking Programs using Black Box Testing -- in Software Quality Journal}
%% \todo{}
%% \todo{}

%Narrative: 
%  What (is the subject),
%  why  (are we exploring it) and 
%  how  (are we doing it)

% the Introduction intro, a bit of 'what'
%% The life-cycle, and often the cost, of most sofware systems is
%% dominated by maintenance effort~\cite{wasnik2013software,DBLP:journals/tplp/SerebrenikSD08,swi-prolog}.
%% %
%% Maintenance may include porting a program to new platforms, or
%% adapting the program to unexpected tasks, but most often is about
%% debugging flaws in the original program.
%% %
%% Early detection and
%% correction of bugs is thus crucial to minimize the total maintenance
%% effort and its associated costs.
%% %
%% Ideally, bug detection would be possible by automatic verification
%% against a specification.
%% %
%% High-level languages, such as logic and functional programming languages
%% offer the promise to achieve this ultimate
%% goal~\cite{wadler1989theorems,cortesi1997specification}.
%% %
%% In practice, testing is still necessary and often crucial for bug
%% detection, and thus a fundamental component in software development.
%% %
%%  %, very widely used and with
%% %growing importance in the industry.
%% % coa: could not introduce industry examples in this text, maybe it is
%% %      not needed
%% % \cite{arts2006testing}
%% %
%% Notice that testing is not a one-shot operation in most software.
%% %
%% Regardless of the formal and constructive nature of logic programming,
%% rare cases and typing mistakes make it necessary to regularly test
%% throughout program development.

%  What (is the subject)
Software testing consists of executing a program on
a pre-selected set of inputs and inspecting whether the outputs
respect the expected results.
%
Each input tested is called a \emph{test case} and the set of inputs is
a \emph{test suite}.
%
Testing tries to find counter-examples
%% Software testing can be classified by the granularity of test focus, the
%% tester point of view or approach.
%% %
%% Tests can focus on the behaviour of single components (unit testing), the
%% correct interaction of components (integration testing) or that the
%% whole system complies to its specification (system testing).
%% %
%% A library user has its access limited to the given interface in order to
%% test its behaviour whereas the developer may want to check invariants
%% and the integrity of internal data-structures.
%
%% How to choose
and choosing 
the test cases %% in a test suite
to this effect
is often a difficult
task.
%
The approach used can be  manual, with the tester designing test cases
one by one, or it can be automated to some extent, in this case
resorting to tools for case generation.
%
Ideally, the best approach would be automatic testing.
%
%% \todo{remover esta frase, vsc?}
%% \todo{Such tools reduce the time needed for testing software components and make
%% it easier to test programs being developed.}


In a property-based framework test cases are automatically generated and run
from assertions about logical properties of the program.
%
Feedback is given to the user about their
evaluation.
%
Property-based testing applications include
black-box, white-box, unit, integration and system testing~\cite{Claessen-ranking-prog-blackbox,Claessen-find-race-cond-erl,Boberg-model-based-testing-erl}.




Property-based testing naturally fits the logic programming paradigm. 
%
%% The high-level nature of the language makes it easy to
%% specify properties. %% test cases.
%
%% On the other hand, 
%% Due to its untyped nature programmers may be
%% oblivious to important corner cases or odd behaviours.
%% %
%% Backtracking can also cause unexpected behaviours. %% in goal conjunctions.
%% Prolog backtracking may also interfere in less than obvious
%% ways, making the run-time behavior elude the programmer.
%% %
%% Being able to automatically test a property about a predicate or set of
%% predicates is thus a clear advantage during software development.
%
Assertions are first order formulas and thus easily encoded as program predicates.
%% \Prolog{}'s ties to logic reduces the gap between the program and the
%% specification of properties. %% to be tested.
%% \todo{tinha um coment\'ario do vsc, nao o entendi}
%
Therefore, a property based approach to testing is intuitive for the
logic programmer.


In this paper we introduce \plqc{}\footnote{The \plqc{} tool is available at \url{www.dcc.fc.up.pt/~coa/PrologCheck.html}.},
a property-based testing framework for \Prolog{}.
%%  inspired on
 %% \QuickCheck~\cite{quickcheck}
%
We further discuss two main contributions: a specification language for \Prolog{} predicates
and a translation procedure into testable properties.


%  why  (are we exploring it) and 



%  how  (are we doing it)
%% \todo{sou contra o comentario para mudar 'generated' para antes de
%%   'automatically' porque também se aplica ao 'run'}
%
In non-logic programming languages interfaces to testing frameworks rely
on boolean functions, such as equality, to determine primitive properties. %%  \todo{em vez de
  %% 'traditional interfaces'}
%% %
%% Since \plqc{} is a tool to test \Prolog{} programs we take advantage of
%% the nature of the language and loosed the requirements for property
%% specification.
%% %
%% Even if they are composed of software units of other types they still
%% need to be able to evaluate to a truth value in order to assess a
%% property validity.
%% %
%% With \Prolog{} %% there are no such restrictions: 
%% any goal may be a property.
%
%% Instead of expecting a reduced set of syntactic elements to describe
%% properties, i
%
\plqc{} states properties through a domain-specific language that
naturally supports domain quantification.
%
In this language primitive properties are %% defined as
\Prolog{} goals which can be composed by \plqc{}
property operators. %combinators.
%% a property is a goal or a composition of
%% properties.
%% \todo{havia aqui um comentario a dizer que estava confuso, espero que
%%   não esteja pior...}



%% A property is satisfied when the execution of the goal, given all
%% necessary input, succeeds or the composition rules are met.
%% %
%% Input %% to such goals is given
%% is based on \plqc{} value abstraction,
%% quantification over a domain represented by a generator of terms.
%
%% Properties can be composed and their validity is defined by the
%% composition operation.
%
\plqc{} testing consists on repetitively calling the goal for a large number of
test cases.
%
%% Singleton properties are pure predicate calls
%% or composed goals whose successful execution determines that the
%% property holds for the given input.
%% %
%% These properties can be composed in order to achieve more complex
%% specifications.
%
%
We implement randomised test case generation, which frees the user
from choosing input manually.
%
We also include a number of predefined generators for relevant sets of
terms, such as integers and lists, and combinators to help define new
generators.
%
The user can define new test case generators or combine
existing ones.
%
Thus other generation techniques
\cite{naylor2007logic,runciman2008smallcheck,Duregard-2012-feat} can be
implemented  to complement the power of built-in generators.
%
%% The interface predicates of \plqc{} test if given properties hold for a number of inputs.

%% %
%% % vsc: this seems too much detail for the Intro
%% %
%% Note that the automatic generation of input for a particular test case of a
%% property is random w.r.t.\ a size parameter for the generated value.
%% %
%% The user has the freedom to decide how to compose the test data
%% generators to best fit the tests' purpose.
%% %
%% From simple generators and using the provided predicate generator
%% combinators it is possible to obtain generators for more complex
%% domains, provide suitable value distributions for specific predicates or
%% predicate usages and to ensure the relation between the input parameters applied
%% to the predicates being tested is valid.



%  overview
%% \plqc{} tool is inspired by \QuickCheck{} and retains its main
%% ideas.
%% %
%% %It is an automatic software testing tool that generates test cases based
%% %on properties written in a dialect of the programming language.
%% %
%% Nevertheless, since \Prolog{} does not possess a static strong
%% type system, the interface of \plqc{} differs from the \Haskell{}
%% \QuickCheck{}.


%% Our tool is
%% lightweight and completely integrated in \Prolog{}.
%% %
%% On top of this lightweight testing tool we have built predicate
%% specification testing.
We also define a language of testable predicate specifications including
types, modes and multiplicity, which the tester can use to encode
interesting properties of the predicate under test.
%% %
%% By specifying some aspects of a predicate in a proper specification
%% language it is possible to generate a \plqc{} property and check it.
%
This allows us to  use \plqc{} and its predicate specification to test a
number of non-trivial programs.


%}}} introduction


%{{{ paper outline
The rest of this paper is organised as follows.
%
\refSecI{sec:rel-work} encloses the presentation of related work.
%
In \refSec{sec:properties} we introduce property definitions and their
testing in \plqc{} and in \refSec{sec:generators} we discuss details
about test case generation.
%
\refSecI{sec:pred-spec} describes the predicate specification language
and how to test the specifications, followed by the presentation of case
studies in \refSec{sec:case-studies}
%
We finalise with the conclusions in \refSec{sec:conclusion}
%}}} outline


