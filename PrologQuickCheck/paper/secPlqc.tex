% -*- mode: latex; mode: folding -*-

\section{Properties}
\label{sec:properties}


The expressive power of properties is the same as \Prolog{} predicates,
since the whole language is allowed.
%
This enables the specification of a good range of properties about
regular predicates through the use of meta-predicates, such as checking
the mode of a term.
%
In this section we give some example how to define properties.


Let us start with an example about reversing lists, for which we assume the
predicate \yap{rev/2}, relating two lists with reversed element order.
%
The property and predicate to be tested are in the same module,
\yap{mod}, and use the \plqc{} tool module.
%
The \yap{rev/2} predicate has a desired behaviours, which
coincides with laws of a reversing operation.
{
\aligncolumn{7}{@@{}>{\hspre}r<{\hspost}@@{}}
\begin{code}
      rev([])   == []
  rev(XS++YX)   == rev(YS) ++ rev(XS)
  rev(rev(XS))  == XS
\end{code}
}
These laws are intended to be satisfied for ground, finite lists
\yap{XS} and \yap{YS}.
%
We represent them as \Prolog{} goals we can run and check.
%
\begin{yapcode}
 rev([], [])
 append(XS, YS, ZS), rev(ZS, RZ),
  rev(XS, RX), rev(YS, RY),
   append(RY, RX, RZ)
 rev(XS, RX), rev(RX, XS)
\end{yapcode}
%
Going into more detail on the third property, we need to match its
semantics to the intended property.
%
As is, it can have multiple meanings depending on its arguments modes.
%
In this particular case we want to express the symmetry of the
\yap{rev/2} relation in terms of its intended use: given a ground
list in one argument retrieve a result in the other.
%
The next step is optional, to generalise the goal and parametrise it
accordingly.
%
\begin{yapcode}
 qcprop({drev, XS}) :-
   rev(XS, RX), rev(RX, XS).
\end{yapcode}
%
We write a clause for the special predicate \yap{qcprop/1}.
%
A call to this predicate in a property causes \plqc{} to inspect the
body of the clause, making it possible to abstract long or frequently
used properties and compose complex properties from smaller elements.
%
This is still not complete to use with \plqc{} for random testing, we
need to specify the domain over which we abstract the property.
\todo{CA: I don't like this sentence much...}
%
\begin{yapcode}
 qcprop(double_rev) :-
   plqc:qcforall(listOf(int), XS,
                 mod:qcprop({drev, XS}))
\end{yapcode}
%
We want to test our \yap{drev} property for random \yap{XS} lists.
%
When a polymorphic operation is being tested it is usually sufficient
to test it for a domain such as integers, so in this particular example
we state the property in terms of lists of integers.
%
We use \plqc{}'s universal quantification to which we describe the
\emph{type} of terms we want to get randomly generated,
\yap{listOf(int)}, the variable to bind the value to, \yap{XS},
and finally the property.
%
Now we can check the property using its alias \yap{mod:qcprop(double_rev)}.
\begin{yapcode}
   ?- plqc:quickcheck(mod:qcprop(double_rev)).
 OK: Passed 100 test(s).
 yes
\end{yapcode}
%
The \yap{plqc:quickcheck/1} predicate is the simplest property tester in
\plqc{}, taking a property as a parameter and checking it for a large
number (100 is the default number) of generated test cases.


We could make the mistake of typing the property wrong, which would deem
it impossible to be satisfied.
%
\begin{yapcode}
 qcprop(wrong_drev) :-
   plqc:qcforall(listOf(int), XS,
                 (plqccase1:rev(XS,RX),
                  plqccase1:rev(RX,RX))).
\end{yapcode}
%
Here we mistakenly make the second call to \yap{rev/2} with \yap{RX} as
the second parameter.
%
\begin{yapcode}
   ?- plqc:quickcheck(plqccase1:qcprop(wrong_drev)).
 Failed: After 7 test(s).
 Counterexample found: [[3,0,1,0]] 
 yes
\end{yapcode}
A counterexample is found and showed in a list with an element for each
generated input value.
%
In this example it is just a list with four elements, but it can show
the sequence of values instantiated in each universal quantification of
the property.
%
A thing to notice here is that a counterexample is only found after a
few tests.
%
This is due to the fact that test cases are randomly generated based on
a maximum size.
%
The size criteria causes it to be more likely to get lists with 0 or 1
element early, which actually obeys the property.


Since properties are \Prolog{} goals,  we get for free the built-in
features to compose goals in a program.
%
We can make logical statements with built-in control predicates:
truth values, conjunction, disjunction, implication or negation.
%
\begin{yapcode}
   true; fail
   rev(XS, RX), rev(RX, XS).
   XS = []; XS = [H||T].
   fail -> true
   \+(fail)
\end{yapcode}
%
Other control predicates, such as cut (\yap{!}), are also allowed in
order to refine the meaning of a property.
%
Extreme care is advised when choosing goals containing impure or
meta-predicates for properties.
%
In a setting with a strong static type system it can ensure that only
safe properties, pure functions or predicates, are allowed.
%
We choose to let the user be free to use more involved properties, who
is then responsible to seek that the impure parts of a property are self
contained and do not interfere with posterior test cases and are not
influenced by previous ones.
\todo{CA: last paragraph a little off the story line}


\section{Generators}
\label{sec:generators}

We saw a reference to \yap{listOf(int)} in the previous example.
%
This is an example of a \emph{generator} in \plqc{}.



There are also some differences between \plqc{} generators and the
generators in a strongly typed version of the tool.
%
In a setting with static types, generators pick values inside a type
according to some criteria.
%
In \plqc{} they are special predicates that randomly choose an element
from a domain.
%
In fact, the generators themselves define the domain by the elements
they generate, regardless of their probability distribution.
%
They define a set of terms and therefore a \emph{type}.
%
This set of terms is not necessarily composed of only ground terms, it
is supposed to exactly represent the form of an input parameter to a
property.


In \plqc{} we differentiate generators from generator predicates.
%
The bridge between the generator and the corresponding generator
predicate is made by \plqc{}'s quantification.
%
A generator is any callable predicate that can generate a value given a
size parameter.
%
The bridge consists of calling the generator it with the extra
arguments: the quantified variable and the current size parameter.
%
The generator predicate can use the size to guide the value
construction.
%
The value is passed to the property by the \plqc{} quantification
through unification.
\todo{CA: this paragraph sound awkward... need to rephrase somehow}



Together with the generator predicates for basic domains, we make
available some predicate combinators to construct more complex kinds of
generators.
%
Generator predicates can have multiple parameters in order to build
values, but the two last arguments must always be, in this order, the
generated value and the size.
%
\begin{yapcode}
 generator_predicate(A1,...,An,Value,Size).
\end{yapcode}
%
When a generator predicate uses another generator predicate to build a
value, the parameter passed is the generator form as seen in the example
where the generator for lists, \yap{lisstOf(int)}, is parametrised by a
generator for its elements.
\todo{CA: long sentence, would be happy to rephrase}
%

\begin{yapcode}
\end{yapcode}

\begin{yapcode}
\end{yapcode}


\begin{yapcode}
\end{yapcode}

\begin{yapcode}
\end{yapcode}

