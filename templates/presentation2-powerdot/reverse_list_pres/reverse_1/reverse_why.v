(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)
Add LoadPath "/home/sheriff/research/why-2.19/lib/coq/".

Require Export Why.

(*Why type*) Definition erl_term: Set.
Admitted.

(*Why type*) Definition erl_list: Set.
Admitted.

(*Why logic*) Definition erlang_list : erl_list -> erl_term.
Admitted.

(*Why logic*) Definition erlang_integer : Z -> erl_term.
Admitted.

(*Why logic*) Definition get_list : erl_term -> erl_list.
Admitted.

(*Why logic*) Definition get_integer : erl_term -> Z.
Admitted.

(*Why axiom*) Lemma get_set_erl_list :
  (forall (l:erl_list), (get_list (erlang_list l)) = l).
Admitted.

(*Why logic*) Definition nil : erl_list.
Admitted.

(*Why logic*) Definition cons : erl_term -> erl_list -> erl_list.
Admitted.

(*Why axiom*) Lemma erlang_list_ax :
  (forall (l:erl_list),
   (exists rl:erl_list, (exists t:erl_term, l = nil \/ l = (cons t rl)))).
Admitted.

(*Why logic*) Definition head : erl_list -> erl_term.
Admitted.

(*Why logic*) Definition tail : erl_list -> erl_list.
Admitted.

(*Why axiom*) Lemma tail_ax :
  (forall (t:erl_term), (forall (l:erl_list), (tail (cons t l)) = l)).
Admitted.

(*Why axiom*) Lemma head_ax :
  (forall (t:erl_term), (forall (l:erl_list), (head (cons t l)) = t)).
Admitted.

(*Why logic*) Definition is_nil : erl_list -> bool.
Admitted.

(*Why axiom*) Lemma is_nil_t_ax :
  (forall (l:erl_list), ((is_nil l) = true <-> l = nil)).
Admitted.

(*Why axiom*) Lemma is_nil_cons_ax :
  (forall (t:erl_term), (forall (l:erl_list), (is_nil (cons t l)) = false)).
Admitted.

(*Why logic*) Definition is_list : erl_term -> bool.
Admitted.

(*Why axiom*) Lemma is_list_t_l :
  (forall (t:erl_term),
   (forall (l:erl_list), (t = (erlang_list l) -> (is_list t) = true))).
Admitted.

(*Why axiom*) Lemma is_list_l_t :
  (forall (t:erl_term),
   (exists l:erl_list, ((is_list t) = true -> t = (erlang_list l)))).
Admitted.

(*Why logic*) Definition erl_list_length : erl_list -> Z.
Admitted.

(*Why axiom*) Lemma erl_list_length_pos_ax :
  (forall (l:erl_list), (erl_list_length l) >= 0).
Admitted.

(*Why axiom*) Lemma erl_list_length_nil_ax : (erl_list_length nil) = 0.
Admitted.

(*Why axiom*) Lemma erl_list_length_cons_ax :
  (forall (l:erl_list),
   (forall (t:erl_term), (erl_list_length (cons t l)) =
    (1 + (erl_list_length l)))).
Admitted.

(*Why logic*) Definition nth : Z -> erl_list -> erl_term.
Admitted.

(*Why axiom*) Lemma nth_head_ax :
  (forall (t:erl_term), (forall (rl:erl_list), (nth 1 (cons t rl)) = t)).
Admitted.

(*Why axiom*) Lemma nth_tail_ax :
  (forall (t:erl_term),
   (forall (rl:erl_list),
    (forall (i:Z), (i >= 2 -> (nth i (cons t rl)) = (nth (i - 1) rl))))).
Admitted.

(* Why obligation from file "reverse.why", line 137, characters 4-491: *)
(*Why goal*) Lemma reverse_aux_po_1 : 
  forall (L: erl_term),
  forall (Lprev: erl_term),
  forall (HW_1: (is_list L) = true /\ (is_list Lprev) = true),
  forall (HW_2: (is_nil (get_list L)) = true),
  ((erl_list_length (get_list Lprev)) =
  ((erl_list_length (get_list L)) + (erl_list_length (get_list Lprev))) /\
  (forall (i:Z),
   (1 <= i /\ i <= (erl_list_length (get_list L)) ->
    (nth i (get_list L)) =
    (nth ((erl_list_length (get_list L)) + 1 - i) (get_list Lprev)))) /\
  (forall (j:Z),
   (1 <= j /\ j <= (erl_list_length (get_list Lprev)) ->
    (nth j (get_list Lprev)) =
    (nth ((erl_list_length (get_list L)) + j) (get_list Lprev))))).
Proof.
(* FILL PROOF HERE *)
intros.
assert ((get_list L) = nil).
elim (is_nil_t_ax (get_list L)).
intros.
apply H.
assumption .
rewrite H.
rewrite erl_list_length_nil_ax.
intuition.
(*---*)
destruct i ; elim H3 ; auto.

elim H4.
auto.
Save.

(* Why obligation from file "reverse.why", line 136, characters 8-76: *)
(*Why goal*) Lemma reverse_aux_po_2 : 
  forall (L: erl_term),
  forall (Lprev: erl_term),
  forall (HW_1: (is_list L) = true /\ (is_list Lprev) = true),
  forall (HW_3: ~((is_nil (get_list L)) = true)),
  ((is_list (erlang_list (tail (get_list L)))) = true /\
  (is_list (erlang_list (cons (head (get_list L)) (get_list Lprev)))) = true).
Proof.
(* FILL PROOF HERE *)
intros.
split.
apply (is_list_t_l (erlang_list (tail (get_list L))) (tail (get_list L))).
reflexivity .

apply ( is_list_t_l
          (erlang_list  ( cons  ( head (get_list L) ) (get_list Lprev) )
          )
                             ( cons  ( head (get_list L) ) (get_list Lprev) )
          ).
reflexivity.
Save.

(* Why obligation from file "reverse.why", line 137, characters 4-491: *)
(*Why goal*) Lemma reverse_aux_po_3 : 
  forall (L: erl_term),
  forall (Lprev: erl_term),
  forall (HW_1: (is_list L) = true /\ (is_list Lprev) = true),
  forall (HW_3: ~((is_nil (get_list L)) = true)),
  forall (HW_4: (is_list (erlang_list (tail (get_list L)))) = true /\
                (is_list
                 (erlang_list (cons (head (get_list L)) (get_list Lprev)))) =
                true),
  forall (result: erl_term),
  forall (HW_5: (erl_list_length (get_list result)) =
                ((erl_list_length
                  (get_list (erlang_list (tail (get_list L))))) +
                (erl_list_length
                 (get_list
                  (erlang_list (cons (head (get_list L)) (get_list Lprev)))))) /\
                (forall (i:Z),
                 (1 <= i /\ i <=
                  (erl_list_length
                   (get_list (erlang_list (tail (get_list L))))) ->
                  (nth i (get_list (erlang_list (tail (get_list L))))) =
                  (nth
                   ((erl_list_length
                     (get_list (erlang_list (tail (get_list L))))) +
                   1 - i) (get_list result)))) /\
                (forall (j:Z),
                 (1 <= j /\ j <=
                  (erl_list_length
                   (get_list
                    (erlang_list (cons (head (get_list L)) (get_list Lprev))))) ->
                  (nth
                   j (get_list
                      (erlang_list
                       (cons (head (get_list L)) (get_list Lprev))))) =
                  (nth
                   ((erl_list_length
                     (get_list (erlang_list (tail (get_list L))))) +
                   j) (get_list result))))),
  ((erl_list_length (get_list result)) =
  ((erl_list_length (get_list L)) + (erl_list_length (get_list Lprev))) /\
  (forall (i:Z),
   (1 <= i /\ i <= (erl_list_length (get_list L)) ->
    (nth i (get_list L)) =
    (nth ((erl_list_length (get_list L)) + 1 - i) (get_list result)))) /\
  (forall (j:Z),
   (1 <= j /\ j <= (erl_list_length (get_list Lprev)) ->
    (nth j (get_list Lprev)) =
    (nth ((erl_list_length (get_list L)) + j) (get_list result))))).
Proof.
(* FILL PROOF HERE *)
intro L.
rewrite (get_set_erl_list (tail (get_list L))).
intro Lprev.
rewrite (get_set_erl_list (cons (head (get_list L)) (get_list Lprev))).
intros.

    assert ((get_list L) = (cons (head (get_list L)) (tail (get_list L)))).
    generalize  (erlang_list_ax (get_list L)).
    intro hX1.
    destruct hX1 as [rl [t Ht]].
    elim Ht ; intro.
    absurd (is_nil (get_list L) = true).
    exact HW_3.
    generalize is_nil_t_ax ; intros.

    destruct (H0 (get_list L)) .
    apply H2 ; assumption.

    rewrite H.
    rewrite head_ax.
    rewrite tail_ax.
    reflexivity.

    assert (forall k:Z, k = k+1-1) as hX3 .
    intros ; omega.

    intuition.
    rewrite H4.
    pattern (get_list L) at 3 ; rewrite H.
    rewrite (erl_list_length_cons_ax  (get_list Lprev) (head (get_list L)) ).
    rewrite (erl_list_length_cons_ax  (tail (get_list L)) (head (get_list L)) ).
    omega.

        (*NEW-------------------------*)
        assert (1<i \/ 1=i).
        omega.
        (*END-------------------------*)

    elim H5 ; intros.

    rewrite H.
    rewrite (nth_tail_ax (head (get_list L)) (tail (get_list L))).
    rewrite (erl_list_length_cons_ax  (tail (get_list L))  (head (get_list L)) ).
    replace (1 + erl_list_length (tail (get_list L)) + 1 - i)
        with (erl_list_length (tail (get_list L)) + 1 - (i-1)).
    apply H6.
    intuition.
    replace (erl_list_length (tail (get_list L)))
        with (erl_list_length (get_list L)-1).
    omega.

    pattern (get_list L) at 1 ; rewrite H
       ; rewrite (erl_list_length_cons_ax  (tail (get_list L)) (head (get_list L)) )
       ; omega.
    
    omega.
    omega.

    rewrite <- H10.
    rewrite H ; rewrite (erl_list_length_cons_ax).
    replace (1 + erl_list_length (tail (get_list L)) + 1 - 1)
        with (erl_list_length (tail (get_list L)) + 1 ).
    replace (nth (erl_list_length (tail (get_list L)) + 1) (get_list result))
        with (nth 1 (cons (head (get_list L)) (get_list Lprev))).
    repeat rewrite (nth_head_ax) ; reflexivity.

    apply (H7 1).
    rewrite (erl_list_length_cons_ax).
    intuition.
        (*NEW-------------------------*)
        assert (forall a : Z, a>=0 -> 1<=1+a).
        intro.
        omega.
        (*END-------------------------*)
    apply H5.
    exact (erl_list_length_pos_ax (get_list Lprev)).

    omega.

        (*NEW-------------------------*)
        assert (1<j \/ 1=j).
        omega.
        (*END-------------------------*)

    elim H5 ; intros.
    

    pattern j at 1 ; rewrite (hX3 j).
    rewrite <- ( nth_tail_ax (head (get_list L)) (get_list Lprev) (j+1)).
    replace (erl_list_length (get_list L) + j)
        with  (erl_list_length (tail (get_list L)) + (j+1)).
    apply (H7 (j+1)).
    intuition.
    rewrite erl_list_length_cons_ax.
                    (*NEW-------------------------*)
                    assert (forall (a:Z) (b:Z),
                                   a <= b  -> a+1 <= 1+b
                               ).
                    intros;omega.
                    (*END-------------------------*)
    apply (H5  j  (erl_list_length (get_list Lprev))) ; assumption.
    
    pattern (get_list L) at 2 ; rewrite H ; rewrite erl_list_length_cons_ax.
    omega.
    omega.

    rewrite <- H10.
    replace (erl_list_length (get_list L) + 1)
        with  (erl_list_length (tail (get_list L)) + (1+1)).
    pattern 1 at 1 ; rewrite (hX3 1).
    rewrite <- ( nth_tail_ax (head (get_list L)) (get_list Lprev) (1+1)).
    apply (H7 (1+1)).
    intuition ; rewrite erl_list_length_cons_ax ; omega.

    omega.
    pattern (get_list L) at 2 ; rewrite H ; rewrite erl_list_length_cons_ax.
    omega.
Save.

(* Why obligation from file "reverse.why", line 158, characters 5-36: *)
(*Why goal*) Lemma reverse_po_1 : 
  forall (L: erl_term),
  forall (HW_1: (is_list L) = true),
  ((is_list L) = true /\ (is_list (erlang_list nil)) = true).
Proof.
(* FILL PROOF HERE *)
intros.
split.
assumption.
apply (is_list_t_l (erlang_list nil) nil).
reflexivity.
Save.

(* Why obligation from file "reverse.why", line 159, characters 4-219: *)
(*Why goal*) Lemma reverse_po_2 : 
  forall (L: erl_term),
  forall (HW_1: (is_list L) = true),
  forall (HW_2: (is_list L) = true /\ (is_list (erlang_list nil)) = true),
  forall (result: erl_term),
  forall (HW_3: (erl_list_length (get_list result)) =
                ((erl_list_length (get_list L)) +
                (erl_list_length (get_list (erlang_list nil)))) /\
                (forall (i:Z),
                 (1 <= i /\ i <= (erl_list_length (get_list L)) ->
                  (nth i (get_list L)) =
                  (nth
                   ((erl_list_length (get_list L)) + 1 - i) (get_list result)))) /\
                (forall (j:Z),
                 (1 <= j /\ j <=
                  (erl_list_length (get_list (erlang_list nil))) ->
                  (nth j (get_list (erlang_list nil))) =
                  (nth ((erl_list_length (get_list L)) + j) (get_list result))))),
  ((erl_list_length (get_list L)) = (erl_list_length (get_list result)) /\
  (forall (i:Z),
   (1 <= i /\ i <= (erl_list_length (get_list L)) ->
    (nth i (get_list L)) =
    (nth ((erl_list_length (get_list L)) + 1 - i) (get_list result))))).
Proof.
(* FILL PROOF HERE *)
rewrite (get_set_erl_list ).
intros.
intuition.
rewrite H1.
rewrite erl_list_length_nil_ax.
omega.
Save.

