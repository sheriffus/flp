% -*- mode: latex; mode: folding -*-

\section{Case Studies}
\label{sec:case-studies}

\subsection{List Processing}
We started to write small predicates and specifications along with the
tool development.
%
These small examples turned out to be interesting to show some of the
potential of \plqc{}.
%
They helped to reveal discrepancies between intended and actual
behaviour of the predicates.
%
The tool is specially useful for people that are beginning logic
programming or have their logic programming polluted by other
programming styles, such as one of the authors.


\subsubsection{List Reverse}
Here we return to the first example given in \refSec{sec:properties}.
%
In general people have a conception of what is reversing the order of
elements, which is to observe the $i^th$ element of the original list as
the $(1+n-i)^th$ element of the reversed one for a list of size $n$.
%
There is also the idea of how to code such a procedure, independently of
the programming language.
%
In fact, there are quite a few ways to implement it and we played with
some implementations of the procedure.


What we intend to check about our reverse procedures is the ability to
transform an input list into its reversed counterpart.
%
This implies that the property has an input for random testing.
%
For the automatic generation of input we must decide what is the input.
%
When a procedure is polymorphic on the type of the elements of an
argument list it is usually sufficient to check its behaviour for a
single type of elements.
%
It is sometimes sufficient a finite number of values, but we can
safely overestimate the size of the type.
%
We choose to test the list predicates with lists of integer elements.
%
Therefor we use the generator for integers, \yap{int}, with the
parametric list generator, \yap{listOf(int)}.


We start with two implementations of reverse.
%
The first uses an appending predicate, described later, and the second
builds the result with an accumulator via an auxiliary predicate.
%
\begin{yapcode}
 rev_app([],[]).
 rev_app([X||XS], YS) :-
   rev_app(XS,ZS), append(ZS, [X], YS).

 rev_acc([], LR, LR).
 rev_acc([X||XS], Acc, LR) :-
   rev_acc(XS, [X||Acc], LR).

 rev_acc(L, LR) :-
   rev_acc(L, [], LR).
\end{yapcode}


We can adapt the properties in \refSec{sec:properties} to both versions.
%
We do it by identifying the property names and called predicates
appropriately.
%
For the \yap{rev_app/2} predicate we have.
\begin{yapcode}
 qcprop(double_rev_app) :-
   plqc:qcforall( listOf(int), L,
     mod:qcprop({double_rev_app_body, L})).

 qcprop({double_rev_app_body, L}) :- 
   mod:rev_app(L, LR),
   !, % enforce first solution
   mod:rev_app(LR, L2), !, L == L2.
\end{yapcode}
%
The version for \yap{rev_acc/2} is obtained by changing the affix of
identifiers from \yap{app} to \yap{acc}
%
Both properties underwent testing, passing all given tests.
%
%   ?- plqc:quickcheck(plqccase1:qcprop(double_rev_app), [{numtests, 1000}]), plqc:quickcheck(plqccase1:qcprop(double_rev_acc), [{numtests, 1000}]).
\begin{yapcode}
   ?- plqc:quickcheck(
          (mod:qcprop(double_rev_app))
        qcand (mod:qcprop(double_rev_acc)),
          [{numtests, 1000}]).
 OK: Passed 1000 test(s).
 yes
\end{yapcode}


To check that the order is being reversed we can randomly choose an
element (or even a random set of elements) and inspect if it is
correctly positioned in the reversed list.
%
Choosing random elements prevent us from checking the whole list.
%
\begin{yapcode}
 qcprop(rev_app_index) :-
   plqc:qcforall(
     suchThat(structure({listOf(int), int}),
       plqccase1:valid_index),
     {L,I},
     mod:qcprop({double_rev_index_body, L, I})
   ).
 valid_index({L, I}) :-
   length(L,X), I<X.

 qcprop({double_rev_index_body, L, I}) :- 
   mod:rev_app(L, LR),
   length(L,X),
   Index is I+1, RevIndex is X-I,
   lists:nth(Index, L, Val),
   lists:nth(RevIndex, LR, Val).
\end{yapcode}
%
When performing a large number of tests this method should give good
element coverage.
%
\begin{yapcode}
   ?- plqc:quickcheck(
        mod:qcprop(rev_app_index),
        [{numtests, 1000}]).
 OK: Passed 1000 test(s).
 yes
\end{yapcode}


But since we have two implementations of the same concept we can explore
this by only performing tests on one version and stating a property
comparing their behaviours.
%
\begin{yapcode}
 qcprop(equiv_acc_app) :-
   plqc:qcforall( listOf(int), L,
     (mod:rev_acc(L,LR), mod:rev_app(L,LR))).
\end{yapcode}
The comparison succeeds if both have the same behaviour.
%
\begin{yapcode}
   ?- plqc:quickcheck(
        mod:qcprop(equiv_acc_app),
        [{numtests, 1000}]).
 OK: Passed 1000 test(s).
 yes
\end{yapcode}



\subsection{AVL Trees}
\subsection{red-black Trees}



\begin{yapcode}
\end{yapcode}
\begin{yapcode}
\end{yapcode}
\begin{yapcode}
\end{yapcode}
