% -*- mode: latex; mode: folding -*-
\documentclass[11pt]{article}
%% ,twoside % option to make duplex printing make a cover with a blank reverse

\usepackage{techReps}
\usepackage{epsfig}

\usepackage[utf8]{inputenc}

\usepackage{listings}

\lstset{language=Prolog}          % Set your language (you can change
                                  % the language for each code-block
                                  % optionally)
%style for prolog programs
\lstdefinestyle{yap}{
  language=Prolog,
%  basicstyle=\small\ttfamily,
%  basicstyle=\footnotesize\ttfamily,
  basicstyle=\fontsize{8}{9.6}\ttfamily,
%  basicstyle=\scriptsize\ttfamily,
  keywordstyle=\ttfamily,
  %% keywordstyle=\ttfamily\bfseries,
  showstringspaces=false,
  otherkeywords={ <->, (,) },
}
%% \providecommand{\yap}[1]{\lstinline[style=yap]@#1@}%
\lstnewenvironment{yapcode}
  %% {\lstset{style=yap}\lstset{basicstyle=\small\ttfamily}}
  %% {\lstset{style=yap}\lstset{basicstyle=\footnotesize\ttfamily}}
  {\lstset{style=yap}\lstset{basicstyle=\fontsize{8}{9.6}\ttfamily}}
  %% {\lstset{style=yap}\lstset{basicstyle=\scriptsize\ttfamily}}
  {}

\newcommand{\yap}[1]{\lstinline[style=yap]{#1}}


\newcommand{\Yap}[0]{{\sf Yap}}
\newcommand{\Prolog}[0]{{\sf Prolog}}
\newcommand{\plqc}[0]{{\sf PrologCheck}}

\makeatletter
\def\cleardoublepage{\clearpage\if@twoside \ifodd\c@page\else%
\hbox{}%
\thispagestyle{empty}
\newpage%
\if@twocolumn\hbox{}\newpage\fi\fi\fi}
\makeatother

\begin{document}

\trtitle{PrologCheck Case Studies}
\trauthor{Cláudio Amaral\hspace{0.5cm} Mário Florido \hspace{0.5cm}
Vítor Santos Costa}


\trnumber{PrologCheck Reports\\Version $1.0$ September 2013}
%% \trnumber{DCC-2006-07\\Version $1.1$ September 2013}

\mkcoverpage

\title{AVL Trees}
\author{Cláudio Amaral\hspace{0.5cm} Mário Florido \hspace{0.5cm}
Vítor Santos Costa\\ {\tt \{coa,amf,vsc\}@dcc.fc.up.pt}}
%% \author{author\thanks{author is funded by FCT grant
%% SFRH/BD/XXXXX/20XX.}\hspace{0.5cm} author 2 \hspace{0.5cm}
%% etc\\ {\tt \{xxx,xxx,xxx\}@dcc.fc.up.pt}}

\date{}
\cleardoublepage

\maketitle



AVL trees are implemented in a \Yap{} module,  \yap{avl.yap}, making it interesting to
%% test in order to
show black-box testing with \plqc{}.
%
Its interface is small, with predicates%% only three predicates, 
to create an empty
tree, insert an element and look up an element, respectively
\yap{avl_new/1}, \yap{avl_insert/4} and \yap{avl_lookup/3}.
%
%% With only this interface and knowledge about the trees' shape we can
%% test weather the module implements AVL trees correctly.
%
When performing this kind of test one does not simply test individual
predicates, we test usages of the module.
%
%% In order t
To do this we must be able to create sequences of interface
calls and inspect intermediate results.
%
%% To inspect intermediate results it is necessary to perform some
%% interface calls and study the result terms.
Knowledge about the shape of data is gathered by manual testing if it is
not known.

\section*{Generator}

%{{{

Creating a valid sequence of interface calls is not difficult, but
requires attention to detail.
%
First, we only want to generate valid sequences
%
%% This is important
to save effort of checking validity and not suffer
from sparse valid values.
%
Usages of the module have two sets of important terms: key
terms, and value terms.
%
We decided to parametrise these sets as generators.
%
%% Along with generators for keys and tree values
We also parametrise a
generator for failed look-ups that must be disjoint from the generator
of values.
%
In this generator we start by creating the tree, independently of the
size parameter.
%
This implies that when size is 0 an empty AVL-tree is still created.
%
Thus, we always append the tree creation to a sequence of calls to insert and look-up
values.
%
\begin{yapcode}
 genAvl(KeyGen, ValGen, FGen, Calls, Size) :-
   Calls = [(avl:avl_new) | Cs1], genAvlCmds(KeyGen, ValGen, FGen, [], Cs1, Size).
\end{yapcode}


Generation of commands to insert and look-up values is passed the
information about keys and values.
%
Each element of the sequence is obtained by randomly choosing between insert, valid look-up and invalid
look-up.
%
After an insert command is added, the inserted key-value is saved in a
look-up list to draw future valid look-ups from.
%
Valid look-ups are not generated if the look-up list is empty.
%
When the size parameter reaches zero, we generate an empty list of
commands.
%
Otherwise a command is generated and the size is decreased at least by
one and at most to half.
%
Commands are generated without the context tree, which is managed by
the property.
%
\begin{yapcode}
 genAvlCmds(KeyGen, _ValGen, _FGen, _Lookups, [], 0) :- !.
 genAvlCmds(KeyGen, ValGen, FGen, Lookups, Cs, Size) :-
   genCmdHead(KeyGen, ValGen, FGen, Lookups, X, Size), call(KeyGen, Key, Size),
   ( X = {i, Val}, Cs = [{i, avl:avl_insert(Key, Val)}||CsS],
     NewLookups = [ {Key,Val} || Lookups]
   ; X = {fl, {FK, FV}}, Cs = [{fl, avl:avl_lookup(FK, FV)}||CsS]
   ; ( X = {l1, {K, V}}, Lx=l1; X = {l2, {K, V}}, Lx=l2),
     Cs = [{Lx, avl:avl_lookup(K, V)}||CsS] ),
   MinSize is Size // 2, MaxSize is Size-1, choose(MinSize, MaxSize, NewSize, Size),
   genAvlCmds(KeyGen, ValGen, FGen, NewLookups, CsS, NewSize).
\end{yapcode}


Choosing a single command follows a couple of restrictions.
%
If the generator for failing look-ups is missing, these commands will
not be generated.
%
If the list of look-ups is empty, valid look-ups will not be generated.
%
Valid look-ups can take two forms: checking if the key-value is in the
tree and asking for the value corresponding to some key.
%
All commands are branded by a command identifier, making it possible to
distinguish between different kinds of look-up.
%
The possible choices are bundled in a \yap{frequency} generator.
%
The relative probabilities are such that we get a big variety of commands within
relatively small sequences. 
%
\begin{yapcode}
 genCmdHead(KeyGen, ValGen, none, [], X, Size) :- !,
   plqc:structure({plqc:value(i), ValGen}, X, Size).
 genCmdHead(KeyGen, ValGen, none, Lookups, X, Size) :- !,
   Insert = plqc:structure({plqc:value(i), ValGen}),
   Lookup1 = plqc:structure({plqc:value(l1), plqc:elements(Lookups)}),
   Lookup2 = plqc:structure({plqc:value(l2), plqc:elements(Lookups)}),
   plqc:frequency([{6,Insert}, {2,Lookup1}, {2,Lookup2}], X, Size).
 genCmdHead(KeyGen, ValGen, FGen, [], X, Size) :- !,
   Insert = (...),
   FailLookup = plqc:structure({plqc:value(fl), {KeyGen, FGen}}),
   plqc:frequency([{9,Insert}, {1, FailLookup}], X, Size).
 genCmdHead(KeyGen, ValGen, FGen, Lookups, X, Size) :-
   Insert = (...), FailLookup = (...),
   Lookup1 = (...), Lookup2 = (...),
   plqc:frequency([{6,Insert}, {2,Lookup1}, {2,Lookup2}, {1, FailLookup}], X, Size).
\end{yapcode}
%% \begin{yapcode}
%     plqc:structure({plqc:value(i), ValGen}),
%     plqc:structure({plqc:value(i), ValGen}),
%     plqc:structure({plqc:value(fl),
%                     {KeyGen, FGen}}),
%     plqc:structure({plqc:value(l1),
%                     plqc:elements(Lookups)}),
%     plqc:structure({plqc:value(l2),
%                     plqc:elements(Lookups)}),
%% \end{yapcode}


Together with the generators for module usages we need the generators
for keys and values.
%
Keys are integers between $0$ and $50000$, a large enough interval to
generate a fair amount of unique keys in smaller test cases.
%
Values are non-negative integers bound by the size.
%
To construct a disjoint generator we use singleton lists with elements
given by the value generator.
\begin{yapcode}
 genKey(Key, Size) :- plqc:choose(0, 50000, Key, Size).

 genVal(Val, Size) :- plqc:choose(0, Size, Val, Size).

 genFVal([Val], Size) :- plqc:choose(0, Size, Val, Size).
\end{yapcode}

%}}}


\section*{Property}

%{{{ generic property

The avl property depends on several factors.
%
It is parame\-trised by the tree to check and by operations to extract
information from that tree.
%
These operation consist of: current node's key; key comparison; left and
right sub-trees; empty tree test.
%
A side effect of the property is returning the height of the tree.
%
The empty tree test is a callable term that checks if the tree in the
first argument is empty and unifies the second argument to the
appropriate truth value.
%
Key comparison is callable with three parameters: first key, second key
and result.
%
The result of the comparison reflects the relation between the given
keys : \yap{lt, gt, eq, lte, gte}.
%
\begin{yapcode}
 pcprop({avl, (tree, T), (height, H),
      (curr_key, GetKey), (cmp_key, CmpKeys),
      (left, L), (right, R),
      (is_nil, IsNil)}) :- 
   pcif(...).
\end{yapcode}


A tree may be empty, in which case we just unify the correct height.
%
In the case of a non-empty tree we retrieve its key and sub-trees.
%
They are used in recursive checks of the property.
%
The recursive calls are for a different predicate, accumulating lists of
keys that should be greater of less then the keys of the tree.
%
After checking the sub-trees, the returned heights are compared for
balance and the current tree height computed.
%
\begin{yapcode}
   pcif( (call(IsNil, T, V), V = false)
   ,((call(GetKey, T, Key),
       call(L, T, LT),  call(R, T, RT))
   pc_and
     pcprop({avl, (gt, [Key]), (lt, []),
 (tree, LT), (height, LH),
 (curr_key, GetKey), (cmp_key, CmpKeys),
 (left, L), (right, R), (is_nil, IsNil)})
   pc_and
     pcprop({avl, (gt, []), (lt, [Key]),
 (tree, RT), (height, RH),
 (curr_key, GetKey), (cmp_key, CmpKeys),
 (left, L),(right, R),(is_nil, IsNil)})
   pc_and
     (( abs(LH-RH) =< 1, !
     ; print(height_mismatch), nl, fail),
     H is 1+ max(LH,RH))
   ),
   (V=false, H = 0) )
\end{yapcode}
%% \begin{yapcode}
%%    pcif( (...)
%%    ,((call(GetKey, T, Key),
%%        call(L, T, LT),  call(R, T, RT))
%%    pc_and
%%      (...)
%%    pc_and
%%      (...)
%%    pc_and
%%      (...)
%%    ),
%%      (...) )
%% \end{yapcode}
%
%% \begin{yapcode}
%%    pcif( (...)
%%    ,( (...)
%%    pc_and
%%      pcprop({avl, (gt, [Key]), (lt, []),
%%  (tree, LT), (height, LH),
%%  (curr_key, GetKey), (cmp_key, CmpKeys),
%%  (left, L), (right, R), (is_nil, IsNil)})
%%    pc_and
%%      pcprop({avl, (gt, []), (lt, [Key]),
%%  (tree, RT), (height, RH),
%%  (curr_key, GetKey), (cmp_key, CmpKeys),
%%  (left, L),(right, R),(is_nil, IsNil)})
%%    pc_and
%%      (( abs(LH-RH) =< 1, !
%%      ; print(height_mismatch), nl, fail),
%%      H is 1+ max(LH,RH))
%%    ),
%%      (...) )
%% \end{yapcode}


The accumulating version of the property receives as extra arguments the
lists of keys in the path up to the root that are greater and less then
the current key.
%
This order criterion is what differentiates the accumulating property.
%
It is checked for the current key which is then added to the appropriate
accumulators in the recursive calls.
% (tree, T),
%       (height, H), (curr_key, GetKey),
%       (cmp_key, CmpKeys), (left, L),
%       (right, R), (is_nil, IsNil)
\begin{yapcode}
 pcprop({avl, (gt, GTS), (lt, LTS), ...}) :-
   pcif(
     (...)
   ,(
     (call(GetKey, T, Key), call(L, T, LT),
      call(R, T, RT),
      (forall(member(X, LTS),
       call(CmpKeys, X, Key, lte)), !
      ; print(avl_key_not_inorder1), nl, fail),
      (forall(member(X, GTS),
       call(CmpKeys, X, Key, gt)), !
      ; print(avl_key_not_inorder2), nl, fail))
   pc_and (...)
   pc_and (...)
   pc_and (...)
   ),
     (...)
   ).
\end{yapcode}


To access the fields of trees generated and maintained by \yap{avl.yap}
we examine the product of some calls.
%
After inspecting the resulting trees we implement the operations needed
for the generic property.
%
We complement this with the key comparison and empty tree check.
%
\begin{yapcode}
 get_key(avl(_Left, Key, _Val,
             _Balance, _Right), Key).
 cmp_keys(K1, K2, Cmp) :-
   print({K1, K2}),
 ( K1 < K2, Cmp = lt
 ; K1 =< K2, Cmp = lte
 ; K1 =:= K2, Cmp = eq
 ; K1 >= K2, Cmp = gte
 ; K1 > K2, Cmp = gt
 ).
 left( avl(Left, _Key, _Val,
           _Balance, _Right), Left).
 right( avl(_Left, _Key, _Val,
            _Balance, Right), Right).
 is_nil( avl(_Left, _Key, _Val,
             _Balance, _Right), false).
 is_nil([], true).
\end{yapcode}

%}}}


With the generator, generic property, and access predicates we proceed to
define the %% top property we will
main test.
%
We quantify over module uses, which are processed in its body.
%
The body is composed by a start and a loop, dealing respectively with
 tree creation and insert/look-up commands.
%
The start consumes the tree creation command and checks if the generated
tree is an empty avl tree.
%
The resulting empty tree is fed to the loop with any remaining interface
calls.
%
The loop consumes the command list a command at a time.
%
An insert command requires that the resulting tree be checked for the
avl property.
%
%% \end{yapcode}
%% %
%% \begin{yapcode}
%% \end{yapcode}
%% %
%% %             (height, H),
%% %             (curr_key, avlTest:get_key),
%% %             (cmp_key, avlTest:cmp_keys),
%% %             (left, avlTest:left),
%% %             (right, avlTest:right),
%% %             (is_nil, avlTest:is_nil)
%% \begin{yapcode}
%% \end{yapcode}
%
Looking-up a key-value depends on the given label.
%
The labels \yap{l1} and \yap{l2} indicate valid look-ups.
%
In \yap{l1} the key-value look-up is performed directly, in contrast
with \yap{l2} which looks-up the key and matches the returning value
against the expected value.
%%  %% (height, _H),
%%  %%           (curr_key, avlTest:get_key),
%%  %%           (cmp_key, avlTest:cmp_keys),
%%  %%           (left, avlTest:left),
%%  %%           (right, avlTest:right),
%%  %%           (is_nil, avlTest:is_nil)
%%    %% pcprop({avl, (tree, Tree), (...) })
%%    %%   pc_and
%% \begin{yapcode}
%% \end{yapcode}
%%  %% (height, _H),
%%  %%           (curr_key, avlTest:get_key),
%%  %%           (cmp_key, avlTest:cmp_keys),
%%  %%           (left, avlTest:left),
%%  %%           (right, avlTest:right),
%%  %%           (is_nil, avlTest:is_nil)
%%    %% pcprop({avl, (tree, Tree), (...)})
%%    %%   pc_and
%% \begin{yapcode}
%% \end{yapcode}
%
Invalid look-ups are validated by their execution failure.
%%  %% (height, _H),
%%  %%           (curr_key, avlTest:get_key),
%%  %%           (cmp_key, avlTest:cmp_keys),
%%  %%           (left, avlTest:left),
%%  %%           (right, avlTest:right),
%%  %%           (is_nil, avlTest:is_nil)
%%    %% pcprop({avl, (tree, Tree), (...)})
%%    %%   pc_and
%% \begin{yapcode}
\begin{yapcode}
 pcprop(avlUses) :-
   pcforall(avlTest:genAvl(avlTest:genKey,
              avlTest:genVal, avlTest:genFVal),
            Calls, pcprop({avlUses, Calls})).

 pcprop({avlUses, [(avl:avl_new)||Calls]}) :-
   call(avl:avl_new(Tree))
  pc_and
   pcif(
     pcprop({avl, (tree, Tree), (height, 0),
                  (curr_key, avlTest:get_key),
                  (cmp_key, avlTest:cmp_keys),
                  (left, avlTest:left),
                  (right, avlTest:right),
                  (is_nil, avlTest:is_nil)})
   ,(pcprop({avlUses, Tree, Calls}))
   ,(print(avl_new_fail_invariant), nl, fail)).
 pcprop({avlUses, Tree, []}).
 pcprop({avlUses, Tree,
      [{i,avl:avl_insert(Key,Val)}||Calls]}) :-
   call(avl:avl_insert(Key,Val),
        Tree, ContinuationTree)
     pc_and
   pcif(
     pcprop({avl, (tree, ContinuationTree),
             (...) })
   , (pcprop({avlUses, ContinuationTree,
              Calls}))
   , (print(avl_insert_fail_invariant),
      nl, fail)).
 pcprop({avlUses, Tree,
      [{l1,avl:avl_lookup(Key,Val)}||Calls]}) :-
   ( call(avl:avl_lookup(Key,Val), Tree)
   ; print(avl_lookup_not_found_fail),
     nl, fail)
     pc_and
   pcprop({avlUses, Tree, Calls}).
 pcprop({avlUses, Tree,
      [{l2,avl:avl_lookup(Key,Val)}||Calls]}) :-
   (( call(avl:avl_lookup(Key,XVal), Tree)
    ; print(avl_lookup_not_bound_fail),
     nl, fail),
    XVal = Val)
     pc_and
   pcprop({avlUses, Tree, Calls}).
 pcprop({avlUses, Tree,
      [{fl,avl:avl_lookup(Key,Val)}||Calls]}) :-
   ( call(avl:avl_lookup(Key,Val), Tree),
     print(avl_lookup_found_fail), nl, !, fail
   ; true)
     pc_and
   pcprop({avlUses, Tree, Calls}).
\end{yapcode}
%
Note that the labelled property is connected with a \yap{pc_and} operator
where instead it could be in the place of the \yap{true} \Prolog{}
built-in goal.
%
This is due to the fact that \plqc{} does not inspect \Prolog{} goals
and connectives.


It is to be expected that the module satisfy the properties.
%
We run 1000 tests with the test number option.
%
In one of the testing suits, a counterexample popped up.
%
We repeat the tests until we get enough counterexamples to examine.
%
Inspecting the counterexamples we find the reason for the failure.
%
We discover that the counterexamples found have two insertions under the
same key, where the second value is discarded, and a look-up based on
the second insertion.
%
This means that the key generator is not sparse enough for 1000 test,
where the size of generated values grows and the probability of such a
combination appearing starts to show.
%
We decide to do nothing about it since it is a very uncommon event.
%
We could have increased the interval for the generation of keys, which
would be a quick fix yet would not fix the specification bug, instead it would just
make it less common.
%
The best way to fix the specification is to not adding existing keys to
the look-ups list in the command generator or enforcing the picking of
the first insertion of a certain key.
%
The latter is possible by choosing the last entry in the look-ups list
with the key in question.
%
\begin{yapcode}
   ?- plqc:prologcheck(
                avlTest:(pcprop(avlUses)),
                [{numtests, 1000}] ).
 avl_lookup_not_bound_fail
 !
 Failed: After 732 test(s).
 Counterexample found: [[avl:avl_new,
     {i,avl:avl_insert(45157,19)}, ...
     {i,avl:avl_insert(45157,0)}, ...
     {l2,avl:avl_lookup(45157,0)}]] 
\end{yapcode}


In order to  assess the tool and the specification in broader terms we
insert two bugs and test the two erroneous versions of the module.
%
The first bug was introduced by the tester and the second by another
programmer.
%
This still fits the goal of black-box testing because the actual tests
are still performed without knowledge of the module's source.
%
It is the same as testing different closed implementations.


%{{{ wrong 1

To explore the tool potential we inserted a bug.
%
We changed a line in the table that states how the tree will be
re-balanced upon insertion of a new element.
%
The first arguments of the table are input.
%
The first is the state of the balance, and the second where we insert
the new element.
%
The other three columns state if the new state of the tree is balanced,
if the tree increased in height, and if the tree needs further
re-balancing.
%
For example, the two first rows describe a situation where a totally
balanced tree receives a new element.
%
The tree will increase in size and will not be balanced, but we cannot
improve on that, so no re-balancing will be needed.

\begin{yapcode}
 table( -  , left   , -  , yes  , no   ).
% table( -  , left   , <  , yes  , no   ).
 table( -  , right  , >  , yes  , no   ).
 table( <  , left   , -  , no   , yes  ).
 table( <  , right  , -  , no   , no   ).
 table( >  , left   , -  , no   , no   ).
 table( >  , right  , -  , no   , yes  ).
\end{yapcode}
%
%
Testing this version of the implementation shows a counterexample after
less than 100 test cases on average.
%
%% \end{yapcode}
%
The counterexamples found are command sequences where three inserts are
given in the key order $3, 1, 2$
%
What happens is that after inserting the second value, the tree is
unbalanced.
%
This information is erased by the bug, which will allow any number of
left insertions.
%
Another failing sequence of insertions is in the key order $1, 3, 2$.
%
Here the last call will not even give a wrong result, it will simply
fail at the last insertion.
%
This is noticed in this example by the lack of an error message from the
property.
%
%% \begin{yapcode}
%
The only conclusion we can get from the counterexamples is that the
balancing of the tree is probably failing when the tree is unbalanced to
the right and the sub-tree to the left.
\begin{yapcode}
   ?- plqc:prologcheck(
             avlTest:(pcprop(avlUses))).
 height_mismatch
 avl_insert_fail_invariant
 !
 Failed: After 51 test(s).
 Counterexample found:
   [[avl:avl_new,
     {i,avl:avl_insert(22340,0)},
     {i,avl:avl_insert(1488,1)},
     {i,avl:avl_insert(8952,0)}]] 
 yes
   ?- plqc:prologcheck(
             avlTest:(pcprop(avlUses))).
 Failed: After 66 test(s).
 Counterexample found:
   [[avl:avl_new,
     {i,avl:avl_insert(9919,1)},
     {i,avl:avl_insert(39796,0)},
     {i,avl:avl_insert(18564,1)}]]
 yes
\end{yapcode}

%}}}

%{{{ wrong 2

The second bug is purposely inserted by someone that is not involved
with the tests.
%
We examine and write about it as such, starting with the tests.
%
Counterexamples are found in average after at least 200 test cases.
%
The minimal shape found are sequences of 5 insertions.
%
There are two families of counterexamples
%
One is such that the first three elements inserted are the keys $1, 2,
4$, in any order, followed by key $5$ and finally key $3$.
%
In the second the first keys are $2, 4, 5$, also in no particular order,
followed by $3$ and $1$.
%
\begin{yapcode}
   ?- plqc:prologcheck(
               avlTest:(pcprop(avlUses)),
               [{numtests, 1000}] ).
 Failed: After 213 test(s).
 Counterexample found:
   [[avl:avl_new,
     {i,avl:avl_insert(42290,9)},
     {i,avl:avl_insert(17481,5)},
     {i,avl:avl_insert(19130,5)},
     {i,avl:avl_insert(18001,3)},
     {i,avl:avl_insert(4284,1)}]]
 yes
\end{yapcode}
%
These sequences fail when trying to complete the second level of one of
the root's sub-trees.
%
Furthermore, it happens only if the completion takes the order
right-left.


There are no other details we could retrieve information from.
%
As far as black-box testing is concerned the origin of the error cannot
be pinpointed.
%
Although, we can infer we are dealing with a balance issue, since it can
appear with only insertions.
%
We can go as far as saying that the problem appears to be in a left
insertion, not noticeable in the nodes after the root of the tree.


Inspecting the source we can see that the error was caused by another
change to the balance table changed for the first error.
%
In this case, the following change was performed.
%
\begin{yapcode}
 table( >   , left   , -   , yes    , no ).
 % table( >   , left   , -   , no    , no ).
\end{yapcode}
%
This forces a re-balance of an already balanced tree in the speculated
situation - an insertion to the left filling where there is already a
value to the right.

%}}}


\end{document}
