% -*- mode: latex; mode: folding -*-

% should first explain quickcheck and random arguments


\section{Properties}
\label{sec:properties}

\plqc{} is a property based testing framework.
%
% vsc: define what property is first:
Properties are logical statements about software.
%
In order to automate the testing process these are observable properties
inside the language.
%
They specify the behaviour of or the relation between software
elements.
%
The tool automatically generates input for the properties to be tested
and executes them to assess their validity.
% coa: delete comments if sufficient, re-comment otherwise
%
A primitive property is an arbitrary \Prolog{} goal (hence, the whole
language can be used to define properties).
%
Properties can be composed according to composition
rules described in the continuation.
%
%% In the latter case the \plqc{} tool recursively inspects
%% properties according to the composition rules.
%
% vsc: define the composition rules: anything goes?
% coa: later?
%
The expressive power of properties is thus the same as \Prolog{}
predicates.
%
This enables the specification of a wide range of properties about
predicates through the use of meta-predicates, such as checking
the mode of a goal. % coa: here I was thinking of ground(X) and var(Y);
                    % isn't this the mode of a term?
%
Next, in this section we discuss in detail an example of how to define
properties in \plqc{}.


The example is a predicate to reverse lists.
%
We assume the existence of a predicate \yap{rev/2}, relating two lists
with reversed element order.
%
The property and predicate to be tested are in the same module,
\yap{mod}, and will have access to the \plqc{} tool module.
%
The \yap{rev/2} predicate has a set of desired behaviours, which
correspond to the laws of a reversing operation (we use \texttt{++} to
represent composition of lists).
%
Using a functional notation:
{
\aligncolumn{10}{@@{}>{\hspre}r<{\hspost}@@{}}
\aligncolumn{12}{@@{}>{\hspre}r<{\hspost}@@{}}
\begin{code}
(1)        rev([])     == []
(2)     rev(XS++YX)    == rev(YS) ++ rev(XS)
(3)      rev(rev(XS))  == XS
\end{code}
}
These laws are intended to be satisfied for ground, finite lists
\yap{XS} and \yap{YS}.
%
We can represent the above properties as conjunctions of \Prolog{}
goals:
%
\begin{yapcode}
  (1)  rev([], [])
  (2)  append(XS, YS, ZS), rev(ZS, RZ),
        rev(XS, RX), rev(YS, RY),
         append(RY, RX, RZ)
  (3)  rev(XS, RX), rev(RX, XS)
\end{yapcode}
%
Note that verifying the properties for a certain input consists of
executing the code in a \Prolog{} interpreter.
%
Moreover, note that the third property can have multiple meanings
depending on its parameters modes.
%
In this particular case we want to express the symmetry of the
\yap{rev/2} relation in terms of its intended use: given a ground
list in one argument retrieve a result in the other.
%
The next step is optional.
%
The idea is to generalise the goal and parametrise it accordingly.
%
\begin{yapcode}
 qcprop({drev, XS}) :-
   rev(XS, RX), rev(RX, XS).
\end{yapcode}
%
Note that the generalised call is  written as a clause for the special
predicate \yap{qcprop/1}. % vsc: explain why?
                          % coa: this sentence was missing; does it need more?
%
This is \plqc{}'s predicate for labelling properties.
%
When a call to this predicate is found during testing, \plqc{} inspects
the body of the clause, making it possible to abstract long or
frequently used properties and compose complex properties from smaller
elements.
%
This is still not sufficient to verify properties with \plqc{}.
%
In order to enable random testing, we
need to specify the set of values over which we abstract the property.
%
\begin{yapcode}
 qcprop(double_rev) :-
   plqc:qcforall(listOf(int), XS,
                 mod:qcprop({drev, XS}))
\end{yapcode}
%
This more precise definition says that we want to test our \yap{drev}
property over all random lists of integers \yap{XS}.
%
More precisely, we use \plqc{}'s universal quantification,
\yap{qcforall/3}.
%
The first argument describes the \emph{type} of terms we want to
generate randomly, in this case lists of integers,
\yap{listOf(int)}.
%
The second names the variable of interest, in this case \yap{XS}.
%
The third names the property we want to verify.


Next, we can check the property.
%
This is done by calling \plqc{} using the alias
\yap{mod:qcprop(double_rev)} to define the property.
\begin{yapcode}
   ?- plqc:quickcheck(mod:qcprop(double_rev)).
 OK: Passed 100 test(s).
 yes
\end{yapcode}
%
The \yap{plqc:quickcheck/1} predicate is the simplest property tester in
\plqc{}, taking a property as a parameter and checking it for a large
number (100 is the default number) of generated test cases.


We could have made a mistake and mis-typed the property, which would deem
it impossible to be satisfied:
%
\begin{yapcode}
 qcprop(wrong_drev) :-
   plqc:qcforall(listOf(int), XS,
                 (mod:rev(XS,RX),
                  mod:rev(RX,RX))).
\end{yapcode}
%
Here we mistakenly make the second call to \yap{rev/2} with \yap{RX} as
the second parameter.
%
\begin{yapcode}
   ?- plqc:quickcheck(mod:qcprop(wrong_drev)).
 Failed: After 7 test(s).
 Counterexample found: [[3,0,1,0]] 
 yes
\end{yapcode}
A counterexample is found and showed in a list of generated input
values.
%
In this example it is just a list with four elements, but it can show
the sequence of values instantiated in each universal quantification of
the property.
%
We must observe at this point that a counterexample is only found
after trying seven tests.
%
This is due to the fact that test cases are randomly generated based on
a maximum term size.
%
The size criteria causes it to be more likely to get lists with 0 or 1
element early-on, and these small lists actually obey the property.


We can freely compose \Prolog{} goals as properties.
%
These goals are indivisible and the tool does not inspect their content.
%
Namely, we can make logical statements with built-in control predicates:
truth values, conjunction, disjunction, implication or negation.
%
\begin{yapcode}
   true
   fail
   Goal1; Goal2
   Goal1, Goal2
   Goal1 -> Goal2
   \+(Goal)
\end{yapcode}
%
Other control predicates, such as cut (\yap{!}), are also allowed in
order to refine the meaning of a property.
%
Extreme care is advised when choosing goals containing impure or
meta-predicates for properties.
%
For example, when applying a cut this only affects the primitive
property it is inserted in, not the whole property.
%
In a setting with a strong static type system one can ensure that only
safe properties, pure functions or predicates, are allowed.
%
But this is not the case in \Prolog{}.
%
If we want \plqc{} to be able to inspect the structure of a property
it has to be composed with \plqc{} operators.
%
We choose to let the user be free to use more simpler or more involved
properties.
%
This provides extra flexibility but, ultimately, the user
is the one responsible to guarantee that the impure code in a property
is self-contained and thus does not interfere with posterior test
cases and is not influenced by previous ones.


Available operators currently include conjunction, disjunction,
conditional execution and quantification.
%
\begin{yapcode}
   Prop1 qcand Prop2
   Prop1 qcor Prop2
   qcif(Cond, Porp1, Prop2)
   qcforall(Gen, Var, Prop)
   qcprop(Label)
\end{yapcode}
%
Quantification is explained in the example presented in this section.
%
Property labelling is also considered an operation.
%
It has no real effect on the labelled property, but is at the level of
composed properties in the sense that it has an effect in the tool.
%
\plqc{} inspects its body for the occurrence of other tool specific
operations.


Conjunction and disjunction of properties is used in the place where
conjunction and disjunction of goals is expected.
%
The main difference is that \plqc{} descends on the structure of
properties and not on the structure of goals.
%
Using property connectives one can compose labelled properties or any
other \plqc{} property operations.


The conditional \yap{qcif/3} has a similar behaviour to its ISO
\Prolog{} counterpart, only at the level of \plqc{} properties.
%
It enables conditional properties without cut, which would not be
coincident with its semantics in \Prolog{} goals.


\section{Generators}
\label{sec:generators}

We saw a reference to \yap{listOf(int)} in the previous example.
%
This is an example of a \emph{generator} in \plqc{}.



There are  differences between \plqc{} generators and the
generators in a strongly typed version of the tool.
%
In \Haskell{} \QuickCheck{}, or any language with strong types,
generators pick values inside a type according to some criteria.
%
In \plqc{} they are special predicates that randomly choose an element
from a set of values.
%
In fact, the generators themselves define the set by the elements
they generate, regardless of their probability distribution.
%
They define a set of terms and therefore a \emph{type}.
%
This set of terms is not necessarily composed of only ground terms, it
is supposed to exactly represent the form of an input parameter to a
property.


In \plqc{} we differentiate between generators and generator
predicates.
%
The bridge between the generator and the corresponding generator
predicate is made by \plqc{}'s quantification.
%
A generator is any callable term that can generate a value given a
size parameter.
%
The bridge consists of calling the generator with twp extra
arguments: the quantified variable and the current size parameter.
%
The generator predicate can use the size to guide value
construction.
%
The value is passed to the property by the \plqc{} quantification
through unification.


% vsc: say which ones
% coa: it was in a spoken todo between me and amf, now it is written
% coa: delete comments if OK, re-comment if not
Together with the generator predicates for basic sets of values, we make
available some generator combinators to construct more complex
generators.
%
Generator predicates can have multiple parameters in order to build
values, but the two last arguments must always be, in this order, the
generated value and the size.
%
\begin{yapcode}
 generator_predicate(A1,...,An,Value,Size).
\end{yapcode}
%
When a generator predicate uses another generator predicate to build a
value, the parameter passed is in generator form.
%
This is shown in the example,
where the generator for lists, \yap{lisstOf(int)}, is parametrised by a
generator for the integers.


\subsection{Combinators}

\plqc{}'s generator combinators are generator predicates that are
parametrised by other generators.
%
They are used to build generator predicates for complex data and to
adjust the probability distribution of a generator to fit the needs of
the tester.
%
Follows a list with some of the combinators distributed with the tool.


During testing, the tool keeps a record of the size parameter, which
increases with each test case.
%
If the values or part of the values to be generated have to be of a
certain size, we override this parameter with the \yap{resize/4}
combinator.
%
\begin{yapcode}
 resize(NewSize, GenA, A, _Size) :-
   call(GenA, A, NewSize).
\end{yapcode}


Picking an integer in an interval is probably the most common operation
in generators.
%
The \yap{choose/4} predicate discards the size parameter and randomly
chooses an integer between the inclusive range given by the first two
arguments.
%
\begin{yapcode}
 choose(Min,Max, A, _Size) :-
   Cap is Max+1,
   random:random(Min,Cap,A).
\end{yapcode}


We can restrict the values of a generator by some predicate.
%
If not all generated elements for a generator are useful, wrapping it
with \yap{suchThat/4} will select the elements of the generator in the
first argument that satisfy the predicate in the second.
%
\begin{yapcode}
 suchThat(GenA, PredA, A, S) :-
   (
    suchThatMaybe(GenA, PredA, A, S), !
   ;
    stSizeStep(S, S1),
    suchThat(GenA, PredA, A, S1)            
   ).
\end{yapcode}
%
If a generated value is valid, given by a successful call to
\yap{suchThatMaybe/4}, it is returned; if not, the size parameter is
slowly increased to avoid a size without valid values.
%
This is a dangerous combinator in the sense that it can loop
indefinitely  if the the valid values generated are too sparse.


It is hard to find a good generator.
%
Many times, choosing from a set of generators that complement each other
is the best way to generate values with a good distribution.
%
Grouping generators can be done in several ways.
%
We can randomly choose from a list of generators with \yap{oneof/3}.
%
The list of generators given in the first argument must be non-empty.
%
\begin{yapcode}
 oneof(LGenA, A, S) :-
   length(LGenA, Cap),
   choose(1,Cap,I,S),
   lists:nth(I, LGenA, GenA),
   call(GenA, A, S).
\end{yapcode}
%
If a uniform distribution between the generators is not suitable one can
specifically state the proportions of the probabilities to choose each
generator.
%
The first argument of \yap{frequency/3} is a list of pairs
\yap{\{}\emph{weight}\yap{,}\emph{generator}\yap{\}} representing such
proportions.
%
The input list must also be non-empty.
%
A frequency-index list is created with the correct proportions.
%
A generator is then randomly chosen from that list and called
\begin{yapcode}
 frequency(FGL, A, S) :-
   checkFreqWeights(FGL, FIL, Cap),
   choose(1,Cap,I,S),
   lists:nth(I, FIL, GenA),
   call(GenA, A, S).

 checkFreqWeights([], [], 0).
 checkFreqWeights([{W,Gen}||FGS], FIL, Cap) :-
   checkFreqWeights(FGS, FIL1, Cap1),
   addHeads(W,Gen, FIL1, FIL),
   Cap is Cap1 + W.

 addHeads(0, _Gen, L, L) :- !.
 addHeads(K, Gen, LI, LO) :-
   K1 is K-1,
   addHeads(K1, Gen, [Gen||LI], LO).
\end{yapcode}


The \yap{elements/3} generator predicate, similarly to what
\yap{oneof/3} does to generators, randomly chooses an element to
generate from a non-empty list of possible elements.
%
\begin{yapcode}
 elements(AS, A, S) :-
   length(AS, Cap),
   choose(1,Cap,I,S),
   lists:nth(I, AS, A).
\end{yapcode}



To generate lists we have, for example, generators for arbitrary and
fixed length lists.
%
They are all parametrised by a generator for the list elements.
%
Random size lists can be generated by \yap{listOf/3}, which randomly
chooses a list length and uses the \yap{vectorOf/4} fixed length
generator predicate.
%
The latter recurs on the integer given as the first argument, generating
list elements until the list has enough elements.
\begin{yapcode}
 listOf(GenA, AS, S) :-
   choose(0, S, K, S),
   vectorOf(K, GenA, AS, S).

 vectorOf(0, _GenA, [], _Size) :- !.
 vectorOf(K, GenA, [A||AS], Size) :-
   call(GenA, A, Size),
   K1 is K-1,
   vectorOf(K1, GenA, AS, Size).
\end{yapcode}


To build a generator that only produces a certain value, ground or not,
we use \yap{value/3}, giving the element as the first argument.
%
If a fresh variable is needed, one can use the \yap{variable}
generator.
\begin{yapcode}
 value(A, A, _Size).

 variable(X, _Size) :- var(X).
\end{yapcode}
%
In the case where we want to generate values with a certain fixed
structure with random parts we can use \yap{structure/3}
%
This generator predicate descends on the structure of the first
argument, list or tuple, replicating it for the generated value.
%
When there are no more patters, the generator found is evoked and the
generated value put in its place in the value being built.
%
\begin{yapcode}
 structure(X, Y, Size) :-
   var(X), !, var(Y), X=Y.
 structure(X, Y, Size) :-
   var(X), !, var(Y), X=Y.
 structure([], [], Size) :- !.
 structure([SX||SXS], [X||XS], Size) :-
   !,
   structure(SX, X, Size),
   structure(SXS, XS, Size).
 structure({ST}, {T}, Size) :-
   !,
   structure(ST, T, Size),
   structure(SXS, XS, Size).
 structure( (SX, SXS), (X, XS), Size) :-
   !,
   structure(SX, X, Size),
   structure(SXS, XS, Size).
 structure(GenX, X, Size) :-
   call(GenX, X, Size).
\end{yapcode}



\begin{yapcode}
\end{yapcode}

\begin{yapcode}
\end{yapcode}
\begin{yapcode}
\end{yapcode}

