% -*- mode: latex; mode: folding -*-

\section{Case Studies}
\label{sec:case-studies}

\subsection{List Processing}
We started to write small predicates and specifications along with the
tool development.
%
These small examples turned out to be interesting to show some of the
potential of \plqc{}.
%
They helped to reveal discrepancies between intended and actual
behaviour of the predicates.
%
The tool is specially useful for people that are beginning logic
programming or have their logic programming polluted by other
programming styles, such as one of the authors.


%{{{ List Reverse

\subsubsection{List Reverse}
Here we return to the first example given in \refSec{sec:properties}.
%
In general people have a conception of what is reversing the order of
elements, which is to observe the $i^th$ element of the original list as
the $(1+n-i)^th$ element of the reversed one for a list of size $n$.
%
There is also the idea of how to code such a procedure, independently of
the programming language.
%
In fact, there are quite a few ways to implement it and we played with
some implementations of the procedure.


What we intend to check about our reverse procedures is the ability to
transform an input list into its reversed counterpart.
%
This implies that the property has an input for random testing.
%
For the automatic generation of input we must decide what is the input.
%
When a procedure is polymorphic on the type of the elements of an
argument list it is usually sufficient to check its behaviour for a
single type of elements.
%
It is sometimes sufficient a finite number of values, but we can
safely overestimate the size of the type.
%
We choose to test the list predicates with lists of integer elements.
%
Therefor we use the generator for integers, \yap{int}, with the
parametric list generator, \yap{listOf(int)}.


We start with two implementations of reverse.
%
The first uses an appending predicate, described later, and the second
builds the result with an accumulator via an auxiliary predicate.
%
\begin{yapcode}
 rev_app([],[]).
 rev_app([X||XS], YS) :-
   rev_app(XS,ZS), append(ZS, [X], YS).

 rev_acc([], LR, LR).
 rev_acc([X||XS], Acc, LR) :-
   rev_acc(XS, [X||Acc], LR).

 rev_acc(L, LR) :-
   rev_acc(L, [], LR).
\end{yapcode}


We can adapt the properties in \refSec{sec:properties} to both versions.
%
We do it by identifying the property names and called predicates
appropriately.
%
For the \yap{rev_app/2} predicate we have.
\begin{yapcode}
 qcprop(double_rev_app) :-
   plqc:qcforall( listOf(int), L,
     mod:qcprop({double_rev_app_body, L})).

 qcprop({double_rev_app_body, L}) :- 
   mod:rev_app(L, LR),
   !, % enforce first solution
   mod:rev_app(LR, L2), !, L == L2.
\end{yapcode}
%
The version for \yap{rev_acc/2} is obtained by changing the affix of
identifiers from \yap{app} to \yap{acc}
%
Both properties underwent testing, passing all given tests.
%
%   ?- plqc:quickcheck(mod:qcprop(double_rev_app), [{numtests, 1000}]), plqc:quickcheck(mod:qcprop(double_rev_acc), [{numtests, 1000}]).
\begin{yapcode}
   ?- plqc:quickcheck(
          (mod:qcprop(double_rev_app))
        qcand (mod:qcprop(double_rev_acc)),
          [{numtests, 1000}]).
 OK: Passed 1000 test(s).
 yes
\end{yapcode}


To check that the order is being reversed we can randomly choose an
element (or even a random set of elements) and inspect if it is
correctly positioned in the reversed list.
%
Choosing random elements prevent us from checking the whole list.
%
\begin{yapcode}
 qcprop(rev_app_index) :-
   plqc:qcforall(
     suchThat(structure({listOf(int), int}),
       mod:valid_index),
     {L,I},
     mod:qcprop({double_rev_index_body, L, I})
   ).
 valid_index({L, I}) :-
   length(L,X), I<X.

 qcprop({double_rev_index_body, L, I}) :- 
   mod:rev_app(L, LR),
   length(L,X),
   Index is I+1, RevIndex is X-I,
   lists:nth(Index, L, Val),
   lists:nth(RevIndex, LR, Val).
\end{yapcode}
%
When performing a large number of tests this method should give good
element coverage.
%
\begin{yapcode}
   ?- plqc:quickcheck(
        mod:qcprop(rev_app_index),
        [{numtests, 1000}]).
 OK: Passed 1000 test(s).
 yes
\end{yapcode}


But since we have two implementations of the same concept we can explore
this by only performing tests on one version and stating a property
comparing their behaviours.
%
\begin{yapcode}
 qcprop(equiv_acc_app) :-
   plqc:qcforall( listOf(int), L,
     (mod:rev_acc(L,LR), mod:rev_app(L,LR))).
\end{yapcode}
The comparison succeeds if both have the same behaviour.
%
\begin{yapcode}
   ?- plqc:quickcheck(
        mod:qcprop(equiv_acc_app),
        [{numtests, 1000}]).
 OK: Passed 1000 test(s).
 yes
\end{yapcode}

%}}}

\subsubsection{Append}
The implementation of the appending predicate recurs on the first list
and the appended list parameters, leaving the second list uninspected.
%
\begin{yapcode}
 append([], YS, YS).
 append([X||XS], YS, [X||AS]) :-
   append(XS, YS, AS).
\end{yapcode}
%
We check the behaviour of the \yap{append/3} predicate
through its specification with the predicate specification language
presented in \refSec{sec:pred-spec}.
%
The most obvious way to use append is by giving it two lists and expect
the resulting appended list.
%
So the type of such a specification clause is
(\yap{listOf(int),listOf(int),variable}).
%
We can assert that, in this \plqc{} type, parameters input modes are
(\yap{ground, ground, var}) and the output modes (\yap{ground, ground,
  ground}).
%
It should also be the case that this use of the predicate behaves as a
function, expecting exactly one answer.
%
\begin{yapcode}
 mod:append
   of_type (A-(plqc:listOf(int)),
     B-(plqc:listOf(int)), C-(plqc:variable))
   where (i(g, g, v), o(g, g, g))
   has_range {1,1}.
\end{yapcode}
%
Quickchecking this specification clause bears no surprises.
%
\begin{yapcode}
   ?- plqc:quickcheck(
        mod:qcprop(spec_append),
        [{numtests, 1000}]).
 OK: Passed 1000 test(s).
 yes
\end{yapcode}


Although \yap{append/3} has an intended usage, it may be successfully
used in other situations.
%
For example, one can use it to create an open list, by giving a variable
in place of the second list, which remains uninspected.
%
The result is a list with the ground elements of the first list and the
second list variable as the tail, therefor it is neither ground nor
variable.
%
This usage also behaves as a function, since the potentially mutating
part of the input is not a target of pattern matches.
%
\begin{yapcode}
 {mod:append, 1}
   of_type (A-(plqc:listOf(int)),
     B-(plqc:variable), C-(plqc:variable))
   where (i(g, v, v), o(g, v, ngv))
   has_range {1,1}.
\end{yapcode}
%
Testing this specification clause reveals that the \emph{out} part of
the directionality is not satisfied.
%
\begin{yapcode}
   ?- plqc:quickcheck(
        mod:qcprop(spec_append_1),
        [{numtests, 1000}]).
 ..{failed_out_modes,[[o,g,v,ngv]],
                     [[],_10258,_10258]}
 !
 Failed: After 3 test(s).
 Counterexample found: [[[],_10258,_10260]] 
 yes
\end{yapcode}
%
The counterexample given shows that when the first argument is the empty
list, and the other two variables, the output modes do not comply with
the specification.
% when L1 is [], LApp is L2, i.e. var
%
Upon closer inspection it is noted that the base case of the recursion
on the first argument simply unifies the second and third parameters
when it matches an empty list.
%
There are two simple ways of solving this.
%
One is to split the specification clause between input types that only
have empty lists or non-empty lists separately.
%
The other is to add the directionality missing.
%
The correct choice in general is to split the input types, since this is
a matter between disjoint sets of terms.
%
Multiple output directionalities are mainly intended for multiple modes
of the parameters of multiple answers.
%
Given the simplicity of the example we decided to add a directionality.
%
\begin{yapcode}
   where (i(g, v, v), o(g, v, ngv)), o(g,v,v)
\end{yapcode}


%% \begin{yapcode}
%%  {mod:append, 2}
%%    of_type (A-(plqc:variable),
%%      B-(plqc:listOf(int)), C-(plqc:variable))
%%    where (i(v, g, v), o(g, g, g), o(ngv, g, g))
%%    has_range {1,1}.
%% \end{yapcode}
%%  % default 1-inf


\subsection{AVL Trees}
AVL trees are implemented in a \Yap{} module, making it interesting to
test in order to show black-box testing with \plqc{}.
%
Its interface is small, with only three predicates, to create an empty
tree, insert an element and look up an element.
%
The predicates are \yap{avl_new/1}, \yap{avl_insert/4} and
\yap{avl_lookup/3} respectively.
%
With only this interface and knowledge about the trees' shape we can
test weather the module implements AVL trees correctly.


When performing this kind of test one does not simply test individual
predicates (http://imgflip.com/i/1vrhm), we test usages of the module.
\todo{remove joke}
%
In order to do this we must be able to create sequences of interface
calls and inspect intermediate results.
%
To inspect intermediate results it is necessary to perform some
interface calls and study the result terms.


Creating a valid sequence of interface calls is not difficult, but
requires attention to detail.
%
First, we only want to generate valid sequences.
%
This is important to save effort of checking validity and not suffer
from sparse valid values.
%
Usages the module \yap{avl.yap} have two sets of terms important to
define: key terms and value terms.

\begin{yapcode}
% we must create a generator of avl.yap uses (sequences of operations)
% this is parameterised by two disjoint generators that will make the elements for the tree and the elements for failing lookups
genAvl(KeyGen, ValGen, FGen, Calls, Size) :-
% it always starts with creating a tree
% this implies that when size is 0 the tree is still created
        Calls = [(avl:avl_new) || Cs1],
% and then is just a bunch of calls to insert and lookup values
        genAvlCmds(KeyGen, ValGen, FGen, [], Cs1, Size).
\end{yapcode}
\begin{yapcode}

% generating random insertions and randomly choose some of those to lookup after, using difference lists for better append sublists
% zero size means zero calls
genAvlCmds(KeyGen, _ValGen, _FGen, _Lookups, [], 0) :- !. % cut - no other case if the size is 0
genAvlCmds(KeyGen, ValGen, FGen, Lookups, Cs, Size) :-
        genCmdHead(KeyGen, ValGen, FGen, Lookups, X, Size),
        call(KeyGen, Key, Size),
        (X = {i, Val},
% commands are missing the continuations, these  will be controled by the property itself
        Cs = [ {i, avl:avl_insert(Key, Val)} ||CsS],
% update the possible correct lookups
        NewLookups = [ {Key,Val} || Lookups]
    ;
        X = {fl, {FK, FV}},
% just put the failing lookup
        Cs = [ {fl, avl:avl_lookup(FK, FV)} ||CsS]
    ;
        (X = {l1, {K, V}}, Lx=l1 ; X = {l2, {K, V}}, Lx=l2),
        Cs = [ {Lx, avl:avl_lookup(K, V)} ||CsS]
        ),
        MinSize is Size // 2,
        MaxSize is Size-1,
        choose(MinSize, MaxSize, NewSize, Size),
        genAvlCmds(KeyGen, ValGen, FGen, NewLookups, CsS, NewSize)
.

genCmdHead(KeyGen, ValGen, none, [], X, Size) :- !,
        plqc:structure({plqc:value(i), ValGen}, X, Size).
genCmdHead(KeyGen, ValGen, none, Lookups, X, Size) :- !,
        Insert = plqc:structure({plqc:value(i), ValGen}),
        FailLookup = plqc:structure({plqc:value(fl), {KeyGen, FGen}}),
        Lookup1 = plqc:structure({plqc:value(l1), plqc:elements(Lookups)}),
        Lookup2 = plqc:structure({plqc:value(l2), plqc:elements(Lookups)}),
        plqc:frequency([{6,Insert}, {2,Lookup1}, {2,Lookup2}, {1, FailLookup}], X, Size).
genCmdHead(KeyGen, ValGen, FGen, [], X, Size) :- !,
        Insert = plqc:structure({plqc:value(i), ValGen}),
        FailLookup = plqc:structure({plqc:value(fl), {KeyGen, FGen}}),
        plqc:frequency([{9,Insert}, {1, FailLookup}], X, Size).
genCmdHead(KeyGen, ValGen, FGen, Lookups, X, Size) :-
        Insert = plqc:structure({plqc:value(i), ValGen}),
        FailLookup = plqc:structure({plqc:value(fl), {KeyGen, FGen}}),
        Lookup1 = plqc:structure({plqc:value(l1), plqc:elements(Lookups)}),
        Lookup2 = plqc:structure({plqc:value(l2), plqc:elements(Lookups)}),
        plqc:frequency([{6,Insert}, {2,Lookup1}, {2,Lookup2}, {1, FailLookup}], X, Size).


genKey(Key, Size) :-
        plqc:choose(0, 50000, Key, Size).

genVal(Val, Size) :-
        plqc:choose(0, Size, Val, Size).
\end{yapcode}


%% \subsection{red-black Trees}



\begin{yapcode}
\end{yapcode}
\begin{yapcode}
\end{yapcode}
