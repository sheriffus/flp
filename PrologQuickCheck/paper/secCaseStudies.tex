% -*- mode: latex; mode: folding -*-

\section{Case Studies}
\label{sec:case-studies}

%% \subsection{List Processing}
%% We start with small predicates and specifications.%%  in order to show the
%% %% tool.
%% %
%% These small examples demonstrate some of the potential of \plqc{}.
%% %
%% They help in revealing discrepancies between predicate's intended and
%% actual behaviour.


%{{{ List Reverse

%% \subsection{List Reverse}

%% Here we return to the first example given in \refSec{sec:properties}.
%% %
%% %% In general people have a conception of what is reversing the order of
%% %% elements, reversing a list is to observe the $i^th$ element of the original list as
%% %% the $(1+n-i)^th$ element of the reversed one for a list of size $n$.
%% %% %
%% %% There is also the idea of how to code such a procedure, independently of
%% %% the programming language.
%% %% %
%% %% In fact, there are quite a few ways to implement this procedure and we
%% %% discuss several implementations.% of the procedure.
%% %
%% %
%% We want to check attributes of a reversing procedure.
%% %% What we intend to check about our reverse procedures is the ability to
%% %% transform an input list into its reversed counterpart.
%% %
%% %% This implies that the property must have an input for random testing.
%% %irst, f
%% %% For the automatic generation of input
%% First, we must describe what is the input.
%% %
%% The procedure receives a list as first input parameter, and is polymorphic in
%% the type of the list's elements.
%% %% The procedure is polymorphic on the type of the elements of an
%% %% argument list
%% It is usually sufficient to check the behaviour for a
%% single type of elements.
%% %
%% Moreover, sometimes even a type with a finite number of values suffice,
%% but we can safely overestimate the size of the
%% type~\cite{Bernardy-testing-poly-prop}.
%% %
%% %% We choose to test the list predicates with lists of integer elements.
%% %
%% Therefore, we use the generator for integers, \yap{int}, as the elements
%% of the parametric list generator, \yap{listOf(int)}.



%% \begin{yapcode}
%%  rev_app([],[]).
%%  rev_app([X||XS], YS) :- rev_app(XS,ZS), append(ZS, [X], YS).
%% \end{yapcode}


%% For the previous implementation of reverse we can define the 
%% property in \refSec{sec:properties}.
%% %
%% The property underwent testing, passing all given tests.
%% %
%% %   ?- plqc:prologcheck(m:prop(double_rev_app), [{numtests, 1000}]), plqc:prologcheck(m:prop(double_rev_acc), [{numtests, 1000}]).
%% \begin{yapcode}
%%    ?- prologcheck(m:prop(d_rev_app)).
%%  OK: Passed 100 test(s).
%% \end{yapcode}
%% %
%% %% We can adapt the properties in \refSec{sec:properties} to both versions.
%% %% %
%% %% %% We do it by identifying the property names and called predicates
%% %% %% appropriately.
%% %% %
%% %% For the \yap{rev_app/2} predicate we have.
%% %% \begin{yapcode}
%% %%  prop(double_rev_app) :-
%% %%    plqc:for_all(listOf(int), L, m:prop({dbl_rev_app_body, L})).
%% %% 
%% %%  prop({dbl_rev_app_body, L}) :- 
%% %%    m:rev_app(L, LR), !, m:rev_app(LR, L2), !, L == L2.
%% %% \end{yapcode}
%% %% %
%% %% The version for \yap{rev_acc/2} is obtained by changing the affix of
%% %% identifiers from \yap{app} to \yap{acc}
%% %% ,
%% %%           [{numtests, 1000}]
%%  %% OK: Passed 1000 test(s).
%%  %% yes


%% To check that the order is being reversed we can randomly choose an
%% element (or a %even a random
%%  set of elements) and inspect
%%  its position in the parameters.
%% %% if it is correctly positioned in the reversed list.
%% %
%% Choosing random elements prevent us from checking the whole list.
%% %
%% \begin{yapcode}
%%  prop(rev_app_i) :- plqc:for_all(
%%      suchThat(structure({listOf(int), int}), m:valid_index),
%%      {L,I}, m:prop({double_rev_i_body, L, I}) ).
%%  valid_index({L, I}) :- length(L,X), I<X.

%%  prop({double_rev_i_body, L, I}) :- 
%%    m:rev_app(L, LR), length(L,X), Index is I+1, RevIndex is X-I,
%%    lists:nth(Index, L, Val), lists:nth(RevIndex, LR, Val).
%% \end{yapcode}
%% %
%% When performing a large number of tests this method should
%%  randomly choose enough indexes to 
%% give good
%% element coverage.
%% %
%% \begin{yapcode}
%%    ?- prologcheck(m:prop(rev_app_i)).
%%  OK: Passed 100 test(s).
%% \end{yapcode}

%% %% We start with
%% We have another implementation of reverse.
%% %, described later, 
%% While the first implementation uses concatenation, the following
%% builds the result with an accumulator via an auxiliary predicate.
%% %
%% %% With proper property labelling  and predicate calls we can define
%% %% \yap{prop(d_rev_app)} and \yap{prop(d_rev_acc)} to depict the
%% %% behaviour of \yap{rev_app/2} and \yap{rev_acc/2} respectively.
%% %
%% The same property is defined for the new implementation with the same
%% testing result.
%% \begin{yapcode}
%%  rev_acc([], LR, LR).
%%  rev_acc([X||XS], Acc, LR) :- rev_acc(XS, [X||Acc], LR).

%%  rev_acc(L, LR) :- rev_acc(L, [], LR).
%% \end{yapcode}


%% Since we have two implementations of the same concept we can explore
%% this by 
%% %% only performing tests on one version and
%% stating and testing a property comparing their behaviours.
%% %
%% \begin{yapcode}
%%  prop(eqv_acc_app) :-
%%    for_all(listOf(int), L, (rev_acc(L,LR),rev_app(L,LR))).
%% \end{yapcode}
%% The comparison succeeds if both have the same behaviour.
%% %
%% \begin{yapcode}
%%    ?- prologcheck(m:prop(eqv_acc_app)).
%%  OK: Passed 100 test(s).
%% \end{yapcode}

%}}}

%{{{ append

\subsection{Append}
%% The %% \Prolog{}
%% implementation of the list concatenation predicate recurs on the first list
%% and the appended list parameters, leaving the second list uninspected.
%% %
Here we describe in more detail properties of  \yap{app/3}:
%
%% \todo{no texto fica melhor   \yap{append/3} ou 'append' em texto normal?}
\begin{yapcode}
 app([], YS, YS).
 app([X||XS], YS, [X||AS]) :- app(XS, YS, AS).
\end{yapcode}
%
We check the behaviour of the predicate through its specification with
the predicate specification language presented in
\refSec{sec:pred-spec}.
%


%% The most obvious way to use \yap{append/3} is by giving it two lists and expect
%% the resulting appended list.
%% %
%% So the type of such a specification clause is
%% (\yap{listOf(int),listOf(int),variable}).
%% %
%% We can assert that, in this \plqc{} type, parameters input modes are
%% (\yap{ground, ground, var}) and the output modes (\yap{ground, ground,
%%   ground}).
%% %
%% It should also be the case that this use of the predicate behaves as a
%% function, expecting exactly one answer.
%% %
\yap{app(A,B,C)} is used in a functional way in many programs,
i.e., by giving it two lists as input and getting their concatenation as
output.
%
This behaviour is specified in \plqc{} as:
 %% (plqc:listOf(int), plqc:listOf(int), plqc:variable)
\begin{yapcode}
 app of_type (A-(listOf(int)), B-(listOf(int)), C-(variable))
   where (i(g, g, v), o(g, g, g))  has_range {1,1}.
\end{yapcode}
%
\emph{Prologchecking} this specification clause bears no surprises.
%
\begin{yapcode}
   ?- prologcheck(m:prop(spec_app)).
 OK: Passed 100 test(s).
\end{yapcode}


%% Although
\yap{app/3} %% has an intended usage, it
may be %% successfully
also
used in other situations.
%
For example, one can use it to create an open list, by %% giving a variable
%% in place of the second list, which remains uninspected.
calling it with a variable in the second input parameter.
%
The result is a list with the ground elements of the list and the
variable in the second parameter as the tail, therefore it is neither ground nor
variable.
%% %
%% This usage also behaves as a function, since the potentially mutating
%% part of the input is not a target of pattern matches.
%
\begin{yapcode}
 {app, 1} of_type (A-(listOf(int)), B-(variable), C-(variable))
   where (i(g, v, v), o(g, v, ngv))  has_range {1,1}.
\end{yapcode}
%
Testing this specification clause reveals that the \emph{out} part of
the directionality is not satisfied.
%   ?- plqc:prologcheck(m:prop(spec_app_1)).
\begin{yapcode}
  ?- prologcheck(m:prop(spec_app_1), [noshrink]).
 {failed_out_modes,[[o,g,v,ngv]], [[],_10258,_10258]}
 Failed: After 3 test(s).
 Counterexample found: [[[],_10258,_10260]] 
\end{yapcode}
%
The counterexample shows that when the first input parameter is the empty
list, %% and the other two variables,
the output modes do not respect %% comply with
the specification %% .
%% % when L1 is [], LApp is L2, i.e. var
%% %
%% Upon closer inspection it is noted that
because
the base case of the recursion
%% on the first input parameter simply
unifies the second and third parameters.
%% when it matches an empty list.
%
%% There are two %% simple
%% ways of solving this problem.
%% %
%% One is to split the specification clause between input types that only
%% have empty lists or non-empty lists separately.
%% %
%% The other
One way to solve it 
is to add the missing directionality \yap{(i(g, v, v), o(g, v, ngv)), o(g,v,v)}.
%
%% The correct choice in general is to split the input types, since this is
%% a matter between disjoint sets of terms.
%% %
%% Multiple output directionalities are mainly intended for multiple modes
%% %% of the parameters
%% of multiple answers.
%% %
%% Given the simplicity of the example we decided to add a directionality.
%% %
%% \begin{yapcode}
%%    where (i(g, v, v), o(g, v, ngv)), o(g,v,v)
%% \end{yapcode}


%% \begin{yapcode}
%%  {m:append, 2}
%%    of_type (A-(plqc:variable),
%%      B-(plqc:listOf(int)), C-(plqc:variable))
%%    where (i(v, g, v), o(g, g, g), o(ngv, g, g))
%%    has_range {1,1}.
%% \end{yapcode}
%%  % default 1-inf

%}}}

\subsection{AVL Trees}

We have described AVL properties and performed black-box testing of an
implementation of AVL trees in a \Yap{} module, \yap{avl.yap}, with
\plqc{}\footnote{All the details can be found in the tool's website.}.
%%
Due to space restrictions we only present a general description of the
process and its results. 


The module interface is small, with predicates to create an empty
tree, insert an element and look up an element, respectively
\yap{avl_new/1}, \yap{avl_insert/4} and \yap{avl_lookup/3}.
%
When performing this kind of test one does not simply test individual
predicates but rather usages of the module.
%
To do this we must be able to create sequences of interface
calls and inspect intermediate results for compliance with AVL
invariants.
%
Knowledge about the shape of input/output terms can be gathered manually
if it is not previously known.


\paragraph{\bf Generator}

Creating a valid sequence of interface calls is not difficult, but
requires attention to detail.
%
First, we only want to generate valid sequences to save effort of
checking validity and not suffer from sparse valid values.
%
Using the \yap{avl} module implies the existence of two sets of important
terms: key terms, and value terms, which we represent as generators.
%
In order to test the correct failure of wrong look-ups, a set of values
for failed look-ups disjoint from the regular values is also
implemented.


The generator starts by creating the tree, independently of the
size parameter, using \yap{avl_new/1}.
%
This implies that when size is 0 an empty AVL-tree is still created.
%
Thus, we always append the tree creation to a sequence of calls to
insert and look-up values.
%
Each element of the sequence is obtained by randomly choosing between
insert and look-ups.


When an insert command is added to the sequence, the value to be
inserted is kept so that it can be used in later look-ups.
%
Look-ups are divided between valid look-up and invalid look-up.
%
Valid look-ups are only generated after the corresponding insert and
invalid look-ups are based in a set of values that is never inserted.
%
Valid look-ups can be further distinguished between looking up a
key-value pair and looking up a key and retrieving its value.
%
These elements are  branded by a command identifier to recognise their
correct behaviour during testing.
%
The relative probabilities are such that we get a big variety of commands within
relatively small sequences.



%}}}

%% \paragraph{\bf }

%% \subsubsection*{Property}
\paragraph{\bf Property}

%{{{ generic property

The definition of the AVL property depends on several factors.
%
It is necessary to have operations to extract information from trees,
such as current node's key, key comparison, left and
right sub-trees and empty tree test.


A tree may be empty, in which case it is an AVL tree of height 0.
%
In the case of a non-empty tree we retrieve its key and sub-trees.
%
They are used in recursive checks of the property.
%
The recursive calls accumulate lists of keys that should be greater and
less then the keys in the sub-trees.
%
If the sub-trees are individually compliant with the property, we
proceed with the last check, comparing the returned heights for
balance and computing the current tree height.
%
This is how the property is outlined in \plqc{}:
%

%\pagebreak 
      %% ((forall(member(X, Ls), cmpKeys(X, K, lte))) -> true; error1),
      %% ((forall(member(X, Gs), cmpKeys(X, K, gt))) -> true; error2))
   %% and (( abs(Hl-Hr) =< 1 -> true; error3), H is 1+max(Hl,Hr))),
\begin{yapcode}
prop({avl, T, Gs, Ls, H}) :- if (not isNil(T)) then
 ((getKey(T, K), left(T, L),  right(T, R),
      ((forall(member(X, Ls), cmpKeys(X, K, gt))) -> error1),
      ((forall(member(X, Gs), cmpKeys(X, K, lte))) -> error2))
   and prop({avl, L, [Key||Gt], Lt, Hl})
   and prop({avl, R, Gt, [Key||Lt], Hr})
   and (( abs(Hl-Hr)>1 -> error3), H is 1+max(Hl,Hr)))
 else (H = 0).
\end{yapcode}
%
We complete the property by inserting it into a loop that consumes the
operations in the quantified module uses.



\refTabI{tab:avl-tests} summarises some relevant results of our tool
applied to the AVL library.
%
Each line corresponds to a different module version: line 1 to the
original version; line 2 to a bug in the re-balancing strategy inserted
by the tester; line 3 to a different bug also in the re-balancing
strategy inserted by someone that was not involved with the tests.
%
The column \emph{Tests} is the number of tests needed to achieve a
particular counter-example.
%
For the purpose of readability we will represent only the key and value
input parameters of the AVL operations.
%
Thus consider \yap{i(N,V)} as insert an
element with key \yap{N} and value  \yap{V}, and \yap{l(N,V)} as look up
the pair \yap{(N,V)} in the tree.


Note that the counter-example found in the original version corresponds
to an unspecified behaviour in the case of two insertions with the same key.
%
After several runs of the tool (10 for the first bug and 20 for the
second) we managed to find a pattern on the counter-examples which led
to the identification of the pathological behaviour caused by the bugs.


\begin{table}
  \centering
  \begin{tabular}{||c||c||l||}
    \hline
    Version    &  Tests   &  Counter-example
    \\ \hline
    Original   &  732     &  \yap{i(1,a), i(1,b), l(1,b)}
    \\ \hline
    Error 1    &  51      &  \yap{i(3,a), i(1,b), i(2,c)}
    \\ \hline
    Error 2    &  213     &  \yap{i(5,a), i(2,b), i(3,c), i(4,d), i(1,e)}
    \\ \hline
  \end{tabular}
  \caption{{\tt avl} testing summary.}
  \label{tab:avl-tests}
\end{table}


%% We run 1000 tests and no bug is detected, as expected for a relatively
%% smaller library module.
%% %
%% The only unspecified behaviour we discover is about two insertions under the
%% same key, and a look-up based on the discarded insertion.
%% %
%% This means that the key generator is not sparse enough for 1000 test,
%% where the size of generated values grows and the probability of such a
%% combination appearing starts to show.

%}}}

%{{{ wrong 1

%% To explore the tool potential we inserted a bug in the module.
%% %
%% We changed a line in the table that states how the tree will be
%% re-balanced upon insertion of a new element.
%% %
%% We changed the information stating that a perfectly balanced tree leans
%% left after inserting an element that increases the left sub-tree height
%% to ignore the balance change.
%% %
%% Testing this version of the implementation shows a counterexample after
%% less than 100 test cases on average.
%% %
%% The counterexamples found are command sequences where three inserts are
%% given in the key order $3, 1, 2$
%% %
%% Another failing sequence of insertions is in the key order $1, 3, 2$.
%% %
%% The conclusion we can get from the counterexamples is that the
%% balancing or balance calculation of the tree is probably failing.

%}}}

%{{{ wrong 2

%% A second bug is purposely inserted by someone that is not involved
%% with the tests.
%% %
%% From the perspective of the tester we start with the tests.
%% %
%% Counterexamples are found in average after at least 200 test cases.
%% %
%% The minimal shape found are sequences of 5 insertions.
%% %
%% There are two families of counterexamples
%% %
%% One is such that the first three elements inserted are the keys $1, 2,
%% 4$, in any order, followed by key $5$ and finally key $3$.
%% %
%% In the second the first keys are $2, 4, 5$, also in no particular order,
%% followed by $3$ and $1$.
%% %
%% These sequences fail when trying to complete the second level of one of
%% the root's sub-trees.
%% %
%% Furthermore, it happens only if the completion takes the order
%% right-left.


%% There are no other details we could retrieve information from.
%% %
%% As far as black-box testing is concerned the origin of the error cannot
%% be pinpointed.
%% %
%% Although, we can infer we are dealing with a balance issue, since it can
%% appear with only insertions.
%% %
%% We can go as far as saying that the problem appears to be in a left
%% insertion, not noticeable in the nodes after the root of the tree.


%% Inspecting the source we can see that the error was caused by another
%% change to the balance table changed for the first error.
%% %
%% The bug inserted forces a re-balance of an already balanced tree in the
%% speculated situation - an insertion to the left filling where there is
%% already a value to the right.

%}}}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5555





%% %% \subsection{red-black Trees}

